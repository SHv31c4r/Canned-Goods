# Понятие сетевых операционных систем
* Все современные ОС являются сетевыми
	* Это значит, что помимо средств для управления локальными ресурсами есть есть еще средства для сетевого взаимодействия (предоставления локальных ресурсов другим устройствам)
* Сетевая ОС обеспечивает доступ к другим компьютерам
* Для этого нужны транспортные подсистемы.
* Клиент может только попросить выполнить запрос, поставляющий на сервер. Сервер может выдать ответ.

* Формирование сообщений, определение маршрутов сообщений и защита их передачи - задачи транспортной подсистемы.
* Клиент должен уметь перенаправлять запросы.

* Сетевая ОС = набор служб (служба реализует сервис)
* Раньше все ПК были одноранговыми (были и клиентами, и серверами). Для локалок - гуд, но для глобалок - жопа. Поэтому пришли к разделению на клиентское и серверное оборудование.

## Требования к современным сетевым ОС
1. Высокая степень расширяемости
	* Код сетевой ОС должен быть написан так, чтоб его легко можно модифицировать

2. Высокая степень переносимости
	* Сетевая ОС должна работать на самом различной аппаратной платформе

3. По необходимости, сетевые ОС должны быть совместимы
	* ОС должна иметь средства для выполнения программ, написанных для других ОС

4. Надежность и отказоустойчивость
	* Определяется степенью качества написания кода

5. Высокая степень безопасности
	* Должны быть высокая степень аутоинтефикации
	* Разделение уровней доступа пользователь
	* Средства аудита

6. Высокая производительность
	* Максимальная возможность использования аппаратных платформ

## Регламент обмена данных в сети
* Протокол - набор правил, определяющих размер, состав и

* OSI - Open System Interconnection - семиуровневая модель сетевого протокола
	1. Физический уровень - определяет передачу битов по каналу связи (оптоволокно, коаксиальный кабели итд). Ес
		* Полоса пропускания
		* Волновое сопротивление
		* Напряжение
		* Крутизна фронтов импульсов
		* И прочая физика
		
		  * Стандартизируются в основном разъемами
	2. Канальный уровень. Определяются возможности среды по передаче данных. Также занимается определением ошибок.
		* На этом уровне важнее всего - корректная передача кадров (данных, разбитых на сегменты)
		* Реализуется адаптерами и драйверами
	3. Сетевой уровень. Создается единая транспортная система от одного удаленного узла другому. Задача - определение маршрута. Этим занимает маршрутизатор (современный роутер). Согласовывает для этого упомянутые технологии.
		* Используется протокол IP
	4. Транспортный уровень. Задача - обеспечить передачу информации заданной степенью надежности. Можно передать сообщения с гарантией или без нее.
		* Гарантию обеспечиает гарантированную передачу - TCP. Протокол, который не обеспечивает гарантию, но дает большую скорость - UDP.
	5. Сеансовый уровень. Определяется диалог между отдельными частями распределенного приложения (клиент-сервер приложения). Используются соответствующие вызовы
	6. Представительный уровень. Речь идет о программном коде, который позволяет предоставить информацию в нужном виде. Например, данные в зашифрованном/дешифрованном видах
	7. Прикладной уровень. Предполагает использование высокоуровневых протоколов для предоставления пользователю указанных ресурсов.
	* Уровни 5-7 по сути своей являются кодом, реализующим программу как клиент-сервер.

## Коммуникационные примитивы сетевых ОС

* Сообщение состоит из двух частей: заголовка и данных
	* Заголовок содержит адреса отправителя и получателя
	* Еще указывается номер сообщения, генерируемый при создании сообщения
	* В данных хранятся три типа полей: имя данных, тип данных и их значение
	* Транспортная подсистема должна скрывать все данные 

Базовыми примитивами являются `send()` и `receive()`
	* Могут реализовываться в составе ядра (тогда программисты не могут к ним напрямую). Тогда в рамках ОС должны быть механизмы по обращению к ним.
	* Могут быть и доступны (входить в API)

Факторы, влияющие на реализацию этих примитивов
	1. Способ задания адреса (IP-адрес, MAC-адрес, символьное имя)
	2. При передаче сообщения получатель один или их несколько
	3. Требуется гарантийная доставка сообщений или нет
	4. Какова реакция системы при отказе в отправке сообщения
	5. Надо ли использовать буферизацию (отправитель сообщение отправил, а получатель еще не готов с ним работать)
	6. Если буферизация есть, то он может переполняться. Что делать при его переполнении (отбросить, подождать, или что?)
	7. Есть приоритизация сообщений. Как получателю их обрабатывать: по порядку получения или по приоритету


### Синхронизация при передаче сообщений
* Примитивы делятся на синхронные (блокирующие) и асинхронные
	* При использовании синхронного примитива `send()` блокируется до момента получения информации, что получатель сообщение получил
	* Вызов блокирующего `recieve()` блокируется до получения им сообщения
	* При использовании асинхронных примитивов управление возвращается непременно после отправки (`send()` и `receive()` могу выполняться взаимно параллельно)
	* Для получения инфы о том, что сообщение дошло, используются два варианта
		1. Отправить проверку-опрос (`test()` - новый примитив). Отправляет его отправитель
		2. Использование прерывания. Сложный способ, но где-то задействован

### Буферизация примитивов передачи сообщений

* Идея - получатель не готов обработать сообщение, но его стоит сохранить. Тогда на стороне получателя должен быть буфер.
* Организация зависит от типа примитивов: для синхронных и асинхронных примитивов она разная.
	* Для синхронных примитивов буферизация теоретически не нужна (из его сути работы). Но ее делают, причем размером в одно сообщение (максимально возможное). Делают тупо для уменьшения временных задержек в сети.
	* В случае с асинхронными примитивами должен быть буфер бесконечного размера, причем только со стороны получателя. Но это невозможно - размер буфера ограничивается при помощи специального примитива `createBuffer()`:
		* Он должен срабатывать до создания сообщения. Он имеет начальный размер
		* Но м.б. ситуация, когда буфер заполнен. Что делается тогда с не вошедшим в буфер сообщением: или оно просто отбрасывается, или держится какое-то время, а после (если оно не зашло в буфер) выдается ошибка-таймаут

### Способы адресации
* Иногда можно использовать MAC-адреса. Но они однозначно идентифицируют только ПК, а нам нужен еще и процесс. Так что он почти не используется
* Обычно используется пара:
	* IP-адрес - идентификатор, показывающий сеть и устройство в нем (первые три указывают сеть, а последнее - номер устройства в сети)
	* Логические номера портов - двухбайтовое число. Этот порт связывается с каким-то портом.
	* Тогда у нас есть и адрес устройства, и номер процесса (формально, номер порта, через который связывается сервер с процессом)
		* Всего их 65535, но первые 1024 (0..1023) заблокированы под спец. нужды
	* Минус - при смене местоположения меняется IP и может еще поменяться порт. Их надо пересчитывать и перекомпилировать программный продукт.
	* Контра - использование символьных имен.
	* Для этого надо отобразить символьное имя на словарь.
	* В случае с глобальной сетью используется DNS.
		* Ставится сервер DNS, где записано соответствие между ip и символьным именем

### Надежные и ненадежные примитивы
* Речь идет о гарантированности доставки сообщения
	* Если используется ненадежный, но быстрый протокол (UDP), то речь идет о дейтограммном способе доставки. Тогда программист сам кодирует гарантированность доставки.
	* Если речь идет о надёжной доставке (TCP)
		TCP работает так
		1. Устанавливается соединение
		2. После уже передает сообщение
		Поэтому и гарантирована передача сообщения

# Некст тема - сокеты и удаленная процедура