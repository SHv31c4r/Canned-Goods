# Описание выполнения второй работы
* Варианты 4-13 предусматривают процесс вытеснения процессов. Оно обязано быть в тестах

### Краткое описание
1. В каждом варианте есть граф на 9 дуг
	Будем рассматривать на примере графа на 4 дуги:
	![[Pasted image 20251014111632.png]]
	
| Задача | Тик | Приоритет | F          |
| ------ | --- | --------- | ---------- |
| A      | 1   | 0         | M[1..n]    |
| B      | 1   | 1         | F1(M)      |
| C      | 1   | 1         | F2(M)      |
| D      | 1   | 2         | F3(F1, F2) |
Задача А генерирует массив (относительно небольшой)
Задачи B и C выполняют какие-то задачи по массиву (они должны быть простенькими, например, поиск min/max)
Задача D выполняет манипуляцию над результатами B и C

**Результат должен представлять собой протокол-таблицу.**

В разных ЯП есть класс TThread (поток). Каждая задача представляет собой поток.
	1. Потоки могут запускать другие потоки
	2. Потоки могут смотреть состояния других потоков. Особенно важно, что они могут смотреть параллельные ему потоки

* Поток может обратиться к тику своего запуска
* Поток должен выводиться, чем он должен вызываться
* Д.б. инфа о результате работы потока
* Поток может обратиться к тику своего завершения

Поток D должен запускаться по завершению последнего из потока B и C. Для этого потоки должны смотреть состояния друг друга.
После успеха проверки данные должны передаваться в спец. переменную.
И ЭТО НАША КРИТИЧЕСКАЯ СЕКЦИЯ (проверка, какой поток завершился и какой запустит следующий поток после параллельных)
(для этого и нужны семафоры, в плюсах есть функция `lock()`)
	Эта проверка должна быть в "скобках":
	`P(S);`
	`Проверка`
	`V(S);`

ЧТО НЕ НАДО ДЕЛАТЬ:
	1. НЕ ПИШИТЕ СВОИ ДИСПЕТЧЕРЫ НА ОСНОВЕ ФЛАГОВ ЗАВЕРШЕНИЯ (в том плане, что оно будет просто оценивать, завершился ли поток, не указывая, какой поток кого запустил)

### Про графический вывод
Есть класс объектов `TProgressBar`
С его помощью можно графически выводить процесс завершения.
Выводится:
	1. 9 линеечек
	2. Таблица-протокол (заполняется )
	3. Кнопка пуска для потока А
		В потоках B и C, например, будет проверка.
Поле вывода - это тоже критический ресурс
`Synchronize(wr)` - функция для синхронного вывода (`wr` - это функция вывода)

ВАЖНО: если вдруг вы захотели как-то модифицировать массив в параллельных процессах, то массив - это такой же критический ресурс. И его менеджмент - твоя попаболь
# Задача "Читатель и писатель"

#### Условие
Пусть есть некоторый сервер с БД.
К БД идут запросы двух типов с разных устройств:
	1. Читатели (тупо читают данные)
	2. Писатели (модифицируют данные)
Запросы могут быть относительно параллельны
* ВАЖНО: писатели работают только в монопольном режиме (пока ОДИН писатель пишет, другие процессы к БД доступа не имеют)
* Читатели относительно друг друга параллельно читают, причем спокойно. Но пока есть хотя бы один читатель, писатели заблокированы.

#### Как это решается через семафоры
Есть процедуры Reader и Writer (функции, что нихуя не возвращают, они реитерабельные)
Есть два семафора: S и W (реализация любая)
Есть счетчик r, количество параллельных читателей.

1. Пусть писатель зашел что-то писать. Он не заблокируется семафором. Но когда подойдут другие писатели, семафор не пропустит их. И не пройдут так же читатели.
2. Читатель зашел что-то читать. Он сначала блокирует семафор читателей, смотрит, что нет писателей, увеличивает свой счетчик и блокирует семафор , и разблокирует семафор читателей. Теперь читатель читает. Потом аналогично параллельно читатели блокируют свой семафор, уменьшают свой счетчик.

* НЕДОСТАТОК ТАКОГО РЕШЕНИЯ: если будет сравнительно больше читателей, чем писателей, то это будет мешать писателям. И из-за этого очень долго писатели не могут выполнить свою работу. А это жопа. Ты просто не можешь сделать запись ооооочень долго.

Решение этого недостатка предложил Гордеев (да, линукс-дед): 
	* добавился третий семафор
	* Он висит на входах процедур писателя и читателя
	* Из особенностей - ограничивается параллелизм читателей (они могут не пройти шлюз из двух семафоров уже на первом семафоре)

# Задача "С ожиданием"

#### Условие
Взаимодействуют две ПАРАЛЛЕЛЬНЫЕ задачи: первая выполняется, потом обращается ко второй задаче, а после довыоплняется.

Тут начальное значение семафора равно 0. Поэтому при выполнении второй задачи внутри первой первая задача заблокируется. А в рамках второй задачи она деблокируется.

# Любимая операция Кучина - умножение на 0)))

Семафор рассматривается именно как примитив, т.к. программист сам решает, что где и как будет прописано.
