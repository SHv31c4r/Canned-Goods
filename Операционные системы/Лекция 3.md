# Дисциплины диспетчеризации (Дисциплины обслуживания очереди готовых к выполнению задач)
Дисциплины диспетчеризации - это некое правило, по которому определяется порядок доступа задач к выполнению. Помимо этого, оно организует и распределение ресурсов процессора.

Типы диспетчеризации (тут диспетчер никак не может прервать задачи):
1. FCFS - first came first served. Первым пришел процесс - первым выполнился. Она равноправно относится как к легким, так и к тяжелым. Среднее время ожидания из-за этого становится большим.
2. SJN - shortest job next. Самая короткая задача (с самым малым заказным временем обслуживания) будет обслужена процессором раньше более длинных. Из минусов: 
	Допустим, появится задача с быстрым выполнением, но с вводом/выводом. Процесс выполнился, выполняется ввод-вывод. Процессор уже загружен другой задачи. При требовании повторного выполнения этой задачи она улетит в конец.
3. SRT - shortest remaining time. Здесь так же используется заказное время обслуживание. Приоритетнее тот процесс, в котором разница между заказным и уже выделенным временем

Остальные дисциплины будут вытесняющими (диспетчер сможет принимать решения по прерыванию процессов).:
1. RR - Round Robin. Готовые к выполнению задачи получают квант времени. Если задача не выполняется за квант, то она прерывается и отправляется в конец очереди, процессор выполняет следующую.
	* она несложна в реализации

2. Дисциплины на основе абсолютных приоритетами (выполняется задача с относительно высшим приоритетом; меньше номер приоритета - выше сам приоритет). Сам приоритет не меняется.

3. Дисциплины на основе динамических приоритетов. Тут смысл тот же, но приоритет задачи может изменяться. Чем дольше задача висит в очереди готовности, тем выше у нее становится приоритет. Это нужно для гарантии обслуживания всех процессов, вне зависимости от их времени выполнения.

4. Дисциплины на основе нескольких очередей. Диспетчер будет создавать и управлять несколькими очередями, причем у каждой из них может быть своя дисциплина. Там есть два варианта:
	1. Задача не будет переходить в другую очередь до своего завершения (статическая)
	2. Задача сможет переходить в другую очередь до своего завершения (динамическая)

Дисциплины планирования:
1. FCFS - ресурсы получает раньше та задача, которая раньше их попросила
2. SJN - ресурсы получает та задача, у которой меньше заказное 

# Управление оперативной памятью
(имеется в виду управление в мультипрограммного режима)
Управление осуществляется на основе следующих требований:
1. управление в мультипрограммном режиме. В ОЗУ хранятся разные задачи для выполнения
2. Защита памяти. Задача не может просто так получить доступ к памяти, выделенной для другой программы

## Память и отображение. Виртуальное адресное пространство

Как известно, данные хранятся виртуально и физически, вот "иерархия" их отображения:
1. Символьные (логические имена)
Для перехода ↓ используется транслятор
2. Виртуальные адреса
Для перехода ↓ используются ОС и АП
3. Физические адреса

Виды этих отображений
1. Переход от 2 к 3 соответствует машинным кодам
2. Переход от 1 к 2 осуществляется интерпретатором - очень простой версии ОС. Сначала выполнялась трансляция (имени соответствовал какой-либо адрес) 

3. Осуществляется в два этапа:
	1. Осуществляется отображение, на котором каждому имении соответствует 
	2. ОС и АП осуществляет однозначное отображение виртуального адреса физическому.
	Но одним именем может подписаться только один адрес, на все время работы

4. Современный вид отображения остался таким же, но оно выполняется во время выполнения программы
	Тогда одним именем могут подписываться разные адреса


### Распределение памяти разделами

Разбить всю ту область памяти, которая предназначена для пользователя, на сегменты.

Есть коэфф мультипрограммирования - число, которое определяет, сколько программ одновременно обрабатывается в мультипрограммном режиме

Пример организации памяти:
"Простейшее распределение":
	1. Kernel - ядро ОС
	2. Partitions 1-4, в каждой из которых лежат свои задачи
		Из минусов - есть незадействованные участки памяти. 

Распределение памяти разделами с подвижными границами:
	Раздел имел размер загружаемой задачи.
	Для этого нужен был планировщик памяти.
	Он на основе данных о размере загружал задача и модифицировал список областей.
	Из минусов - коэфф мультипрограммирования падает

Распределение памяти разделами с подвижными разделами:
	Можно было перемещать задачу за счет сдвига кода операции
	Но это технически невыполнимо, т.к. тогда при использовании ввода/вывода результаты помещались на старые адреса.
	А если двигать и их, то производительность падала конкретно

