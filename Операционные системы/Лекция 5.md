# Проблемы синхронизации параллельных процессов
* Часть процессов являются параллельными относительно друг друга.
* Процессы потребляют ресурсы, некоторые из которых процессы могут использовать 
* Ресурс вычислительной системы, который требует последовательного использования разными процессами, называется критическим.
* Общая идея: если некоторый ресурс используется параллельным процессом A, то процессы B и С не могут его использовать. Поэтому нужно синхронизировать доступ ресурсов для них. Иначе будет не оч.
	Пример 1: на конкурирующие процессы
	* Pr1: 
		1. R1=x
		2. R1+=1
		3. x=R1;
	* Pr2:
		4. R2=x
		5. R2+=1
		6. x=R2
	* Тогда при прямом порядке x=2, а при порядке 1-2-4-5-6-3 x=1. Здесь x - это критический ресурс.
	
	  Пример 2: так же на конкурирующие процессы
	  * Есть простая БД из одной таблицы: Имя | Статус | Адрес
	  * Процессы 1 и 2 меняют значения Статуса и Адреса соответственно.
	  * Есть некий Иванов, которого повысили, и он переехал.
		  * Общий процесс заключается в загрузке поля в память, правке и выгрузке назад в БД.
	  * Вот начался первый процесс, но он прервался. После начал выполняться второй процесс, причем он выполнился полностью. Тогда при довыполнении первого процесса мы въебем запись с обновленным адресом.
	  Пример 3: Задача поставщик-потребитель
	* Имеются два взаимодействующих процессов:
		* Поставщик - генерирует сообщения и отправляет их в буфер
		* Потребитель - считывает сообщения с буфера и их используется
		* Крит. ресурс - буфер. Параллельное чтение и запись невозможно.
		* Пулл буферов имеет конечный размер. Поэтому оба процесса должны корректно изменять число свободных и занятых буферов в пуле (счетчики). И это так же критический ресурс.

**Критическая секция (критический интервал)** - некоторая последовательность действий, непосредственно связанная с крит. ресурсом.

Базовая задача:
	1. В каждый момент времени только ОДИН процесс может находиться в своем критическом интервале.
	2. Процесс не должен бесконечно долго ждать входа в свой критический интервал.
	3. Процесс не может бесконечно долго оставаться в своем критическом интервале

Возможностей решить данной задачи много: как низкоуровневые, так и высокоуровневые:
1. `[TAS|TS](op1, op2)` - неделимая команда с двумя аперандами. Она значение второго аперанда возвращает первому, а второй аперанд устанавливает в `true.` 
	* Решение рабочее, но есть и недостатки:
		1. Решение не универсально, а только для конкретной задачи
		2. Оно неудобно (для каждого процесса нужно вводить свои переменные)
		3. Оно работает через зацикливание (активное ожидание), что будет минимизировать эффективное время работы процессора.
	* Это самое низкоуровне

# Семафоры Дейкстры
* Семафор - переменная спец. типа. Над ней используется две операции:
	1. `P(S)` - закрытие семафора S
		* Числовое поле семафора декрементируется
		* После осуществляется проверка условия.
		* Если условие выполняется, то процесс, обратившийся к операции `P(S)` блокируется и встает в очередь к семафору
	2. `V(S)` - открытие семафора S
		* Числовое поле семафора инкрементируется
		* После определяется процесс для деблокирования (переход из очереди семафора в состояние готовности) из общего числа заблокированных процессов.
		* Ну и если процессор будет свободен, то он пойдет в работу.
* Семафор в `C++` - переменная типа struct, где одно поле числовое
* Прикол в том, что семафор семантически связывается с определённым ресурсом.
* Операции семафора сильно варьируются от типов семафоров. Например, есть числовые семафоры (значение семафора меняется от одного значения к другому), и двоичные семафоры (мьютоксы, значение семафора или 0, или 1)
* Реализация операций для числового семафора:
	`P(S):
		`S-=1`
		`if (S<0) <заблокировать процесс и закинуть его в очередь к семафору>`
	`V(S):
		`S+=1`
		`if (S<=0) <деблокировать один из заблокированных процессов>`
Вот эта штука может всплыть на экзе, будьте внимательны

* Реализация операций для двоичного семафора:
	`P(S):`
		`if S=1 them S=0, L=0` - инициализируем очередь для заблокированных процессов размером L
		`else`
		`L+=1`
		`<заблокировать процесс>`
	`V(S)` - смотри в методе лабы, там это написано

Эти семафоры используются для решения задачи взаимного исключения. Аналоги семафорных примитивов есть и сейчас.
Достоинства:
	* Один семафор - для любого числа параллельных процессов.
	* Главное - проинициализировать семафор. Больше доп. переменных не надо
	* Нет активного ожидания

## Решение задачи поставщик-потребитель на примере семафоров

Пусть будет `N=100` - размер пулла
Будем использовать три семафора:
1. `S=1` - двоичный семафор
2. `SS=0` - числовой семафор, счетчик занятых буферов
3. `SN=N` - числовой семафор, счетчик свободных буферов
Ну а дальше опять иди смотреть методу к лабе.

