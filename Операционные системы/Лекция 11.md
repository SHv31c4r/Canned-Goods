# Адресация при сегментной адресации
* Исполнительный адрес определяется следующим образом через глобальную таблицу:
	* Идет обращение к [[MortyD14/Операционные системы/Лекция 10| селектору]]
	* Он суммируется с значением GLTD. Получится адрес в GDT (глобальной таблицы дескрипторов)
	* Это значение суммируется с EIP (локальным адресом)
	* Получается адрес сегмента - исполнительный адрес
	* Еще есть невидимый регистр с дескриптором текущего сегмента (кеширование первого уровня).

* При обращении к локальной таблице отличия есть:
	* Суммируется значение GDTR и LDTR. Получается адрес в GDT.
	* Суммирование GDT и селектора даст адрес в LDT
	* Дальше он суммируется с EIP.
	* В невидимый

* При сегментно-страничной организации будет еще один дополнительный шаг

# Защита данных при сегментной адресации

Приняли решение о формирования 4-уровневой системы:
	0. Ядро ОС
	1. Утилиты ОС
	2. Служебные программы
	3. Пользовательские программы

Он используется для определения доступа к сегменту.
	* Есть еще один регистр - CPL (текущей уровень привелегий)

К разным типам сегментов разные правила доступа:
	* Правило для доступа к данным - EPL <= DPL
	* Правило для доступа к стеку - DPL=RPL(из селектора SS)=CPL
	* Правило для доступа к сегменту кода - зависит от многого
		* У программы могут быть подчиненные сегменты. Сегмент считается подчиненным, если к нему есть обращение, и он подчинен тому сегменту, откуда сделано обращение.
		* За это отвечает бит C в правах доступа. И обращение тогда идет через EIP
		* В ином случае идет обращение через шлюз. БЕЗ EIP. При обращении к неподчиненным сегментам основное правило - CPL<=DPL

# Теперь о сегментно страничной организации памяти

* Теперь адрес у нас виртуальный
* Используются новые регистры:
	* CR0. Там интересен бит PG=1. Тогда система работает с сегментно страничной адресацией памяти
	* CR3 (31-12 байты). 

* Теперь 32-битный линейный адрес, состоящий из трех сегментов:
	* table (31-22 байты)
	* page (21-12 байты)
	* byte (11-0 байты)

* Теперь как получить страницу:
	* Суммируется CR3 с сегментом table, получается адрес дескриптора таблицы страниц
	* После суммируется с page, получается адрес дескриптора страницы
	* Суммируется с byte - получается сегмент (Исполнительный адрес)

* Про дескриптор страниц:
	* Состоит из 4 байт (тут именно номер бит)
		* P, 0 бит - присутствие/отсутствие страницы в ОЗУ
		* R/W, 1 бит - разрешение на чтение/запись
		* U/S, 2 бит - возможность доступа. Работает совместно с битом младше
		* PWT, 3 бит - метод обновления внешней кеш-памяти.
		* PCD, 4 бит - разрешение/запрет загрузки страницы во внутреннюю кеш-память
		* A и D, 5-6 бит - флаг обращения и флаг модификации соответственно
		* 9-11 биты - запаска
		* 12-31 биты - смещение

* Для ускорения преобразования адресов используется TLB - Translation Look aside Buffer:
	* Специфическая кеш-память.
	* Состоит из 8 наборов (0-7)
	* Каждый набор состоит из:
		* 4 тега
		* Специальной логической схемы (3 бита) и битов действительности(4 бита)
		* 4 регистра для хранения дескрипторов страниц
	* Кешируются дескрипторы (2-й уровень кеширования)

* Память состоит из 3 частей:
	* Тег (31-15 биты)
	* Индекс (14-12 биты) (определяет номер набора)
	* Смещение (11 -0 биты)

* Преимущества:
	* Не надо бегать и искать адресы

* Недостаток:
	* Их всего 32
	* Решается при помощи упрощенной процедуры LRU для замещения.

##### В процессорах 86 реализована еще одна кеш-память
* Она кеширует блоки данных по 16 байт

Есть и еще одна кеш-память, но она на отдельной микросхеме...
# Про переключение

* Процессор может переключаться с одной задачи на другую
* Для этого надо менять контекст (который лежит в [[MortyD14/Операционные системы/Лекция 10#Аппаратные средства поддержки ОС на примере процессоров i80x86|TSS]])
* В сегменте TSS хранится битовая карта ввода-вывода:
	* Стоит отметить, что там хранится еще указатель на предыдущий TSS

## Как переключается задача
* В `.asm` коде переключение идет по адресу CALL с указанием адреса CS:EIP.
	* Отсюда получается селектор, откуда получается дескриптор TSS, адрес которого и есть адрес нужного сегмента.
	* Далее в TR загружается значение CS
	* Из нового TSS в регистр LDTR переносится значение селектора LTD
	* В регистры грузятся нужные значения новой задачи.
	* Выполняется новая задача

# Некст тема - прерывания