* Когда появились локальные сети, появилась необходимость в сетевой ОС разработать средства для взаимообмена данными между процессами
# Сокеты
* Сокет (socket, гнездо) - точка входа/выхода из процесса в сеть и наоборот.
* С помощью них можно сделать дейтограммные и потоковые соединения.
* В Win и Linux появились соответствующие библиотеки для работы с сокетами.

```
int socket (int domain, int type, int protocol); //Инициализация сокета (домен сети, тип соединеия, протокол);
int bind (int sockfd, ...)
```

* Сокеты могут быть:
	* С предварительным установленным соединением (потоковый режим)
	* С дейтограммным соединением
Команды для взаимодейтсвия:
```
int connect(...); // Клиентская функция (при потоковом соединении)

int listen(...);  // Серверная функция для прослушки 
int accept(...); // Серверная функция для установки соединения
```

* Для приема и передачи данных
* Функции для завершения работы сокета (после выполнения сокет надо закрыть)
	* Его можно закрыть на отправку, получение или на оба сразу

* У сокетов есть недостаток - жесткая установка IP-адресов. Если какой-то адрес поменялся, то надо перекомпилировать клиентскую/серверную связь.
*

# RPC (Удаленные процедуры)
* Идея - отправить команду для выполнения, но она выполняться будет на другом устройстве.
* Результат вернется обратно.
* Сам процесс выполнения должен быть экранирован.

* В реализации RPC участвуют клиент и сервер:
	1. Процесс отправляет запрос на клиентский стаб (заглушку)
	2. Клиентский стаб переформатирует запрос (упаковывает) и передает в ядро ОС на клиентской части.
	3. ОС ядра клиента использует примитивы Send для передачи на серверный ПК.
	4. Сообщение (набор сообщений) принимается при помощи Recieve.
	5. Серверный стаб распаковывает для серверного процесса данные
	6. Ну и далее все обратно от сервера к клиенту
		* У сообщений от клиента и от сервера разные!!!

* Но вся эта шняга работает при условии, что клиент знает адрес сервера. Изначально он его не знает.
* Вот решения:
	1. Строгий. Когда клиент знает строгий IP сервера. Если сервер переедет, то надо переписывать и перекомпилировать программу.
	2. Использование программы-биндера (binder). Он будет прослойкой между клиентом и сервером.
		0. При активизации сервера он копирует свои адреса и интерфейсы на биндер
		1. Клиент при первом обращении идет к биндеру
		2. Биндер отдает клиенту сетевой адрес сервера
		3. Теперь клиент может обращаться к серверу напрямую
		* Минусы:
			* Более сложные протоколы
			* Биндер можно перегрузить, появятся задержки
			* Биндер обязан быть статическим

# Аппаратные средства поддержки ОС на примере процессоров i80x86

* Все аппаратные средства поддержки сосредоточены в процессоре
* Процессоры могут работать в реальном и защищенном режимах. (Реальный - когда мы свой .asm код запускаем)
* Сейчас зачастую процессор работает в защищенном режиме
	* В нем используется 32-разрядная шина.
	* Реализуется механизм защиты программ разных уровней
	* Есть механизмы-ускорители

* Основа - это регистры процессора
* Регистры общего назначения (для 32-бит используется еще приписка E(xtended)):
	* AX - для хранения результатов арифметики
	* BX - для хранения константы
	* CX - для счетчика
	* DX - для операции со строками
	* SI и DI - для смещения относительно какой-либо базы
	* SP - для начального значения стека
	* Но это формально. Фактически используй как хочешь

* Защищенные регистры:
	* Селекторы (регистры сегментов, 16-разрядные):
		1. CS - указатель на дескриптор кодового сегмента
		2. SS - дескриптор сегмента стека
		3. DS, ES, FS, GS - дескрипторы сегментов данных
		* 13 бит уйдет на индекс, 1 бит на TI (тип таблицы: локальный (1) и глобальный (0)) и 2 бита на RPL (уровень привилегии запроса)
	* Указатели инструкций (32-разрядный):
		1. EIP- относительный адрес текущей выполняемой команды
		2. EFLAGS - содержит признаки результата выполнения текущей команды.
	* Управляющие (32-бит):
		1. CR0 - признак работы процессора
		2. CR1 - резервный
		3. CR2 - (при сегментно-страничной сегментации памяти) - для хранения страничного отказа, вызванного отсутствием страницы в виртуальной памяти
		4. CR3 - (при сегментно-страничной сегментации памяти) для физ адреса
	* Регистры системных адресов (48-бит):
		1. GDTR - глобальная таблица регистров (16 бит на размер и 32 на адрес)
		2. LDTR - локальная таблица регистров (16 бит на размер и 32 на адрес)
	* Таск-регистр (TR) - дескриптор специального сегмента (по сути, дескриптор задачи)
	* Доступ к регистрам в локальной таблице сделан через глобальную таблицу. ПОэтому есть регистр LDTR - указывает на сегмент глобального регистра, где лежит локальный

# Дескрипторы сегментов и виртуальное адресное пространство
* Транслятор подготавливает задачу
* К каждому сегменту готовится дескриптор
* Каждый дескриптор весит 8 байт:
	Байты 0,1 и биты 16-19 6-го байта - размер сегмента.
	Байты 2, 3, 4 и  биты 24-31 7-го байта - база
	Младшие биты 5-го байта - права доступа
	Остальные: 
	Бит G
	Бит D
	Бит 0
	Бит X
	Бит P
	Бит DPL