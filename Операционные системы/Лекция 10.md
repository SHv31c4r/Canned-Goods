* Когда появились локальные сети, появилась необходимость в сетевой ОС разработать средства для взаимообмена данными между процессами
# Сокеты
* Сокет (socket, гнездо) - точка входа/выхода из процесса в сеть и наоборот.
* С помощью них можно сделать дейтограммные и потоковые соединения.
* В Win и Linux появились соответствующие библиотеки для работы с сокетами.

```
int socket (int domain, int type, int protocol); //Инициализация сокета (домен сети, тип соединеия, протокол);
int bind (int sockfd, ...)
```

* Сокеты могут быть:
	* С предварительным установленным соединением (потоковый режим)
	* С дейтограммным соединением
Команды для взаимодейтсвия:
```
int connect(...); // Клиентская функция (при потоковом соединении)

int listen(...);  // Серверная функция для прослушки 
int accept(...); // Серверная функция для установки соединения
```

* Для приема и передачи данных
* Функции для завершения работы сокета (после выполнения сокет надо закрыть)
	* Его можно закрыть на отправку, получение или на оба сразу

* У сокетов есть недостаток - жесткая установка IP-адресов. Если какой-то адрес поменялся, то надо перекомпилировать клиентскую/серверную связь.
*

# RPC (Удаленные процедуры)
* Идея - отправить команду для выполнения, но она выполняться будет на другом устройстве.
* Результат вернется обратно.
* Сам процесс выполнения должен быть экранирован.

* В реализации RPC участвуют клиент и сервер:
	1. Процесс отправляет запрос на клиентский стаб (заглушку)
	2. Клиентский стаб переформатирует запрос (упаковывает) и передает в ядро ОС на клиентской части.
	3. ОС ядра клиента использует примитивы Send для передачи на серверный ПК.
	4. Сообщение (набор сообщений) принимается при помощи Recieve.
	5. Серверный стаб распаковывает для серверного процесса данные
	6. Ну и далее все обратно от сервера к клиенту
		* У сообщений от клиента и от сервера разные!!!

* Но вся эта шняга работает при условии, что клиент знает адрес сервера. Изначально он его не знает.
* Вот решения:
	1. Строгий. Когда клиент знает строгий IP сервера. Если сервер переедет, то надо переписывать и перекомпилировать программу.
	2. Использование программы-биндера (binder). Он будет прослойкой между клиентом и сервером.
		0. При активизации сервера он копирует свои адреса и интерфейсы на биндер
		1. Клиент при первом обращении идет к биндеру
		2. Биндер отдает клиенту сетевой адрес сервера
		3. Теперь клиент может обращаться к серверу напрямую
		* Минусы:
			* Более сложные протоколы
			* Биндер можно перегрузить, появятся задержки
			* Биндер обязан быть статическим

# Аппаратные средства поддержки ОС на примере процессоров i80x86

* Все аппаратные средства поддержки сосредоточены в процессоре
* Процессоры могут работать в реальном и защищенном режимах. (Реальный - когда мы свой .asm код запускаем)
* Сейчас зачастую процессор работает в защищенном режиме
	* В нем используется 32-разрядная шина.
	* Реализуется механизм защиты программ разных уровней
	* Есть механизмы-ускорители

* Основа - это регистры процессора
* Регистры общего назначения (для 32-бит используется еще приписка E(xtended)):
	* AX - для хранения результатов арифметики
	* BX - для хранения константы
	* CX - для счетчика
	* DX - для операции со строками
	* SI и DI - для смещения относительно какой-либо базы
	* SP - для начального значения стека
	* Но это формально. Фактически используй как хочешь

* Защищенные регистры:
	* Селекторы (регистры сегментов, 16-разрядные):
		1. CS - указатель на дескриптор кодового сегмента
		2. SS - дескриптор сегмента стека
		3. DS, ES, FS, GS - дескрипторы сегментов данных
		* 13 бит уйдет на индекс, 1 бит на TI (тип таблицы: локальный (1) и глобальный (0)) и 2 бита на RPL (уровень привилегии запроса)
	* Указатели инструкций (32-разрядный):
		1. EIP- относительный адрес текущей выполняемой команды
		2. EFLAGS - содержит признаки результата выполнения текущей команды.
	* Управляющие (32-бит):
		1. CR0 - признак работы процессора
		2. CR1 - резервный
		3. CR2 - (при сегментно-страничной сегментации памяти) - для хранения страничного отказа, вызванного отсутствием страницы в виртуальной памяти
		4. CR3 - (при сегментно-страничной сегментации памяти) для физ адреса
	* Регистры системных адресов (48-бит):
		1. GDTR - глобальная таблица регистров (16 бит на размер и 32 на адрес)
			* Там лежат дескрипторы ядра и сегментов TSS (TaskState Segment, сегмент с контекстом задачи - начальные значения регистров, устройств ввода/вывода), дескрипторы вентилей и шлюзов
			* Создается при загрузке ОС.
			* Модифицируется по ходу работы
		2. LDTR - локальная таблица регистров (16 бит на размер и 32 на адрес)
			* Она у каждой задачи своя
			* Там есть указатели и на таблицы локальных подзадач итд
	* Таск-регистр (TR) - дескриптор специального сегмента (по сути, дескриптор задачи)
	* Доступ к регистрам в локальной таблице сделан через глобальную таблицу. Поэтому есть регистр LDTR - указывает на сегмент глобального регистра, где лежит локальный

# Дескрипторы сегментов и виртуальное адресное пространство
* Транслятор подготавливает задачу
* К каждому сегменту готовится дескриптор
* Каждый дескриптор весит 8 байт:
	Байты 0,1 и биты 16-19 6-го байта - размер сегмента.
	Байты 2, 3, 4 и  биты 24-31 7-го байта - база
	Младшие биты 5-го байта - права доступа
	Остальные: 
	Бит G
	Бит D
	Бит 0
	Бит X
	Бит P
	Бит DPL
# Адресация при сегментной адресации
* Исполнительный адрес определяется следующим образом через глобальную таблицу:
	* Идет обращение к [[MortyD14/Операционные системы/Лекция 10| селектору]]
	* Он суммируется с значением GLTD. Получится адрес в GDT (глобальной таблицы дескрипторов)
	* Это значение суммируется с EIP (локальным адресом)
	* Получается адрес сегмента - исполнительный адрес
	* Еще есть невидимый регистр с дескриптором текущего сегмента (кеширование первого уровня).

* При обращении к локальной таблице отличия есть:
	* Суммируется значение GDTR и LDTR. Получается адрес в GDT.
	* Суммирование GDT и селектора даст адрес в LDT
	* Дальше он суммируется с EIP.
	* В невидимый

* При сегментно-страничной организации будет еще один дополнительный шаг

# Защита данных при сегментной адресации

Приняли решение о формирования 4-уровневой системы:
	0. Ядро ОС
	1. Утилиты ОС
	2. Служебные программы
	3. Пользовательские программы

Он используется для определения доступа к сегменту.
	* Есть еще один регистр - CPL (текущей уровень привелегий)

К разным типам сегментов разные правила доступа:
	* Правило для доступа к данным - EPL <= DPL
	* Правило для доступа к стеку - DPL=RPL(из селектора SS)=CPL
	* Правило для доступа к сегменту кода - зависит от многого
		* У программы могут быть подчиненные сегменты. Сегмент считается подчиненным, если к нему есть обращение, и он подчинен тому сегменту, откуда сделано обращение.
		* За это отвечает бит C в правах доступа. И обращение тогда идет через EIP
		* В ином случае идет обращение через шлюз. БЕЗ EIP. При обращении к неподчиненным сегментам основное правило - CPL<=DPL
