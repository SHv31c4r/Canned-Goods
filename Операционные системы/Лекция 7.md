# Средства синхронизации
(высокоуровневые аналоги семафоров)
Рассматриваем локальные варианты:

### 1. Почтовые ящики и операции с ними

- Почтовый ящик - буфер ОЗУ, создающийся процессом-отправителем, в котором хранится сообщение другому процессу-получателю
- Зачастую в этом буфере хранится ссылка, а не само сообщение (для экономии памяти)
- Естественно, процесс-получатель может только читать сообщение
- Почтовый ящик состоит из:
	1. Заголовок
		* Количество гнезд
		* Размер гнезда
	2. Гнезда
* Стандартным является однонаправленный почтовый ящик (привет задаче поставщик-потребитель)
* Есть еще и двунаправленные, они нужны для диалога между процессами (протокол взаимодействия)
	* Когда говорят о двунаправленном почтовом ящике, то будет храниться еще и ответ от получателя
	* Проблема - отправитель не знает, когда придет ответ от получателя.
	* Поэтому часто используется механизм таймаута: если за определенный промежуток времени получатель не дал ответ, то ОС сама создает фиктивный ответ. Это нужно, чтоб отправитель понимал, что делать дальше
	* Этот механизм почтового ящика реализовывается при помощи наших низкоуровневых семафоров.
* Пример интерфейса для двунаправленного почтового ящика, состоящий из 4 операций:
	1. sendMessage(reciever, message, buffer) - отправление сообщения (message) получателю (reciever) через почтовый ящик (buffer). Ничего не блокиирует
	2. waitMessage(sender, message, buffer) - получатель ждет от отправителя (sender) сообщения (message) по почтовому ящику (buffer). Данная операция блокируется, пока не будет отправки
	3. sendAnswer (result, naswer, buffer) - получатель (или система) (result) (он м.б. реальным или фиктивным) записывает ответ (answer) в потовый ящик (buffer)
	4. waitAnswer(result, answer, buffer) - аналог waitAnswer, но для отправителя
* ИТОГ: он удобен для организации диалогов, но не для синхронизации (хотя и такое он может)

### 2. Мониторы Хоара:

* Монитор - пассивный набор функций и переменных, использующих эти функции
* Пример: квартира - это монитор, функции - это комнаты. Если есть ключ, то человек может войти в нее и зайти в комнаты. Квартира для другого человека (процесс) будет доступна только тогда, когда зашедший в нее человек выйдет из нее и закроет за собой дверь.
* Иными словами, монитор используется в монопольном режиме: пока для процесса не выполнятся все нужные ему функции монитора, другой процесс, которому так же нужен этот монитор, заблокируется.
* Пример монитора:
	`semaphore S;`
	`S=1;`
	`void F1(void){`
	`P(S); F1; V(S)`
	`}`
	`void F2(void){`
	`P(S); F1; V(S)`
	`}`
* Планировщик в любой ОС является примером монитора
* ПРИКОЛ: критической секции в мониторе как таковой нет, хотя ее фактически можно найти среди функций монитора.
* Недостаток высокоуровневых средств: быстродействие (что стандартно).

# Понятие тупика. Примеры тупиков. Условия существования тупиков

* **В вычислительной системе могут появляться ситуации, когда параллельные процессы вечно висят в заблокированном состоянии из-за взаимных блокировок на ресурсы. Такое состояние и называется тупиком**
* Более формальное определение: "Процесс находится в тупике, если он ждет события, которое никогда не произойдет"

* Причин у тупиков две: ошибки программирования (как на уровне ОС, так и не уровне программы) и конкуренция процессов за общий ресурс (более частая).
* Такие ресурсы делятся на два типа:
	1. Системный ресурс (SR). Его свойства
		* Количество единиц такого ресурса постоянно
		* Процесс может освободить ед. ресурса только если он ее заполучил ранее.
		* Пример: аппаратура, таблицы, файлы итд.
	
	2. Расходуемый ресурс (CR). Его свойства
		* Число доступных ед. ресурса CR изменяется по мере того, как приобретаются или освобождаются потребляемые процессами данного ресурса
		* Такой ресурс формально неограничен в количестве
		* Процессы-производители увеличивают число ед. этого ресурса
		* Процессы-потребители его, соответственно, жрут
		* Пример: разные сообщения и сигналы

Пример тупика по ресурсу CR:
	* Есть три процесса, работающие закольцовано: P1->P2->P3->P1...
	* Они общаются через соответствующие почтовые ящики и сообщения (от P1 к P2 идет сообщение M1 по ящику ПЯ2, и аналогично с другими)
	* Программно это выглядит так:
		`sendMessage(Pj, Mk, ПЯj);`
		`waitMessage(Pk, Mj, ПЯk);`
		При: n=1,2,3 j=2,3,1 k=3,1,2
		Шутка в том, что тупика при таком порядке не будет
		НО СТОИТ НАМ ПОМЕНЯТ КОМАНДЫ МЕСТАМИ... и будет ебучий тупик. **Вот и думай горловой**

Пример тупика по ресурсу SR:
	* Есть 2 взаимодействующих процесса P1 и P2
	* Есть 2 системных ресурса R1 и R2
	* И два семафора для взаимного исключения доступа S1=1 и S2=1 (они изначально открыты)
	* Тогда получим следующую таблицу с блокировками по семафорам:

| P1       | P2       |
| -------- | -------- |
| 1. P(S2) | 5. P(S1) |
| ...      | ...      |
| 2. P(S1) | 6. P(S2) |
| ...      | ...      |
| 3. V(S1) | 7. V(S2) |
| ...      | ...      |
| 4. V(S2) | 8. V(S1) |
Получится следующая диаграмма (каждая клетка обозначает состояние каждого процесса)

// - недостижимы по причине P1
\\\ - недостижимы по причине P2
Траектории:
	I. 1-2-3-4-5-6-7-8 - все ок
	II. 5-6-7-8-1-2-3-4 - все ок
	III. 1-2-5-3-6-4-7-8 - будут блокировки (точки блокировки x1 и x2). Они выполнятся
	IV. 1-5-2-6 - пиздец, тупик (клетка с тупиком называется опасным состоянием)

Вот эта самая клетка поможет определить 4 условия возникновения тупика:
1. Условие взаимного исключения, при котором процессы осуществляют монопольный доступ к ресурсам
2. Условие ожидания, при котором процесс, запросивший ресурс, ждет, пока он не освободится, причем у себя он уже держит доступ
3. Условие отсутствия перераспределения, при котором нельзя отжать ресурс у процесса, если он уже выделен
4. Условие кругового ожидания, при котором процессы закольцованы, и ждут ресурсы, которые были заблокированы его предшественником

И для каждой из причин есть решение

# Методы борьбы с тупиками

### 1. Предотвращение тупиков

* Он исходит из принципа, что тупик - это абсолютное зло, поэтому они недопустимы.
* Чтоб тупик был недопустим, нужно подавить хотя бы одно из условий:
	1. Условие взаимного исключения подавляется путем неограниченного разделение всех ресурсов. Причем для некоторых ресурсов это вполне допустимо (например, для драйверов). Но те же самые переменные - нельзя, иначе нахуй мы решали проблему синхронизации процессов
	2. Условие ожидание подавляется путем разрешения всех ресурсов. Проблема - фактически любой ресурс конечен, да и это крайне неприятно
	3. Условие отсутствия перераспределения. Для этого должен быть механизм для насильственного перераспределение. С процессором так можно (привет, диспетчер задач), но вот уже с устройством ввода/вывода, например, так уже нельзя
	4. Условие кругового ожидания контрится ранжированием ресурсов. Для получения процессом высокоранговых ресурсов ему нужно захватить низкоранговые. Для освобождения порядок обратный. И это работает. **ГОЙДА!**
		* Проблема ввода такой иерархии - критическое замедление работы системы. Есть риск того, что процесс захватит ненужный ему ресурс. И это нивелирует наш параллелизм
* ВЫВОД: стратегия предотвращения тупика неэффективна

### 2. Обход тупика. Алгоритм банкира