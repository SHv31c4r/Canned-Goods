# Сегментная организация памяти

* Транслятор подготавливает задачу в виде совокупности сегментов
* Адресация этих сегментов носит непрерывный характер:
	S - виртуальный номер сегмента
	D - смещение относительно 
* Для каждого сегмента транслятор готовит свой дескриптор (дескриптор сегмента)
* При первоначальной загрузки задачи в ОЗУ, в первую очередь, ОС и ЦПУ создают специальную таблицу дескрипторов сегментов (она тоже лежит в ОЗУ)

Как отображается сегмент в физ. память из виртуальной
1. Загрузка сегмента в ОЗУ
	В спец. регистре будет лежать адрес сегмента текущей выполняемой задачи
	* Первая операция - сложение спецрегистра с  виртуальным номером сегмента. Получается местоположение дескриптора
		Pr - признак присутствия/отсутствия сегмента в памяти
		A - начальный адрес сегмента
		R - размер сегмента
		и другие, но на них нам пока похуй
	* Вторая операция - сложение виртуального номера сегмента с начальным адресом - получается физ. адрес
		* Если же сегмент отсутствует, то операция прерывается на подкачку сегмента в ОЗУ
		* Если же D больше R, то мы можем попасть в чужую память. Тогда операция запрещается (да, R тупо для контроля)

Свойства:
	1. Обеспечивает автоматическое перекрытие сегментов
		* Совсем не обязательно, чтоб все сегменты были в ОЗУ
		* Ненужный в данный момент сегмент уходит в swap, на его место записывается нужный сейчас сегмент
	2. Уровень фрагментации памяти достаточно большой
		* Новый сегмент не должен превышать размер того, на чье место он встает
		* Это как раз и связано с разным размером сегментов
	3. Количество дескрипторов = количество сегментов
	4. Количество таблиц = количество процессов

# Страничная организация
* Транслятор готовит задачи как страницы одинакового размера.
* Адресация страниц имеет непрерывный характер
* Виртуальный адрес страницы:
	P - адрес страницы
	I - смещение
* При первоначальной загрузки задачи в ОЗУ ОС и аппаратура создает дескриптор для страниц

Как отображается сегмент в физ. память из виртуальной
	1. Сложение гр. начального адреса таблицы страниц с адресом первой страницы
		* Получается адрес дескриптора страницы:
			* Pr - флаг наличия страницы в ОЗУ
			* F - физический номер страницы
	2. Приписывания = FxL+I, L - размер страницы
		Получается физический адрес.
		Для ускорения размер страницы лучше делать кратным степени двойки. Тогда операция умножения станет операцией сдвига
		Поэтому размер страницы имеет размер от 2^8 до 2^12

Свойства:
1. Обеспечивает автоматическое перекрытие страниц через swapping
2. Уровень фрагментации значительно меньше, чем при сегментной, т.к. у страниц размер одинаковый, так что при выкачки страницы в swap на ее место страница впишется впритык
3. У страниц есть внутренняя фрагментация, определяемая незаполненностью последней страницы задач
	* Пусть задача заготовлена как 10 страниц. Последняя страница в среднем будет заполнена наполовину. Отсюда и сегментация
	* Сделаешь размер страницы большим - будет высокая фрагментация
	* Сделаешь малым - будет много swapping'а, а это уже штраф в быстродействии

# Swapping и его стратегии
Swapping реализуется файловой системой (FAT32, HPFS, NTFS), но под управлением планировщика.
Swapping основан на двух процессах:
	1. Подкачка сегментов/страниц в ОЗУ
	2. Откачка сегментов/страниц

## Стратегии подкачки
1. Опережающая подкачка:
	* Поведение программы хорошо известна заранее, поэтому префом можно все что надо спанировать, подкачать/откачать
	* Но это максимально утопично и отдалено от реальности - предсказать поведение программы сложно

2. Подкачка по требованию:
	* Произошла адресация нужного сегмента, а его нет в ОЗУ - произошла его подкачка

## Стратегии откачки
Основная идея - необходимо прежде всего откачивать те сегменты/страницы, к которым обращение будет максимально нескоро.

1. Случайная откачка:
	* Выбираются случайные сегменты/страницы для откачки
	* Просто создать
	* Хуево работает (в плане максимально неэффективно)

2. FCFS:
	* Первый подкачен - первым откачен
	* Просто реализовать
	* Качество так же плохое

3. LRU:
	* Least Recently Used - прежде всего откачивается тот сегмент/страница, к которой дольше всего не обращались за определенный период времени
	* Реализовать сложнее
	* Качество лучше

4. LFU
	* Least Frequency Used -прежде всего откачивается тот сегмент/страница, к которому обращались меньше всего за указанный промежуток времени
	* Реализовать сложно
	* Качество хорошее
	* Нужно учитывать еще и время появление сегмента/страницы. Иначе будет не очень, когда сегмент появляется в конце указанного промежутка времени, но сразу улетит нахуй в swpa

# Сегментно-страничная организация памяти

* Транслятор подготавливает задачу в виде совокупности сегментов разного размера, которые состоят из страниц одинакового размера
* Адресация страниц в сегменте носит непрерывный характер:
	S - виртуальный номер сегмента
	P - виртуальный номер страницы ВНУТРИ сегмента
	I - смещение внутри страницы
* Для каждого сегмента транслятор готовит свой дескриптор (дескриптор сегмента), а внутри них лежат таблицы дескрипторов страниц этого сегмента
* При первоначальной загрузки задачи в ОЗУ, в первую очередь, ОС и ЦПУ создают специальную таблицу дескрипторов сегментов (она тоже лежит в ОЗУ) и по аналогии
Как отображается сегмент в физ. память из виртуальной:
	1. Обращение к таблице дескрипторов сегментов (сложение S и гр. таблицы дескрипторов сегментов)
		A - размер сегмента в страницах
		L - Размер страницы
	2. Обращение к таблице дескрипторов страниц внутри сегмента (сложение S и A)
		Pr - факт наличия страницы в ОЗУ
		F - физический адрес страницы
	3. Обращение к странице

Эта штука сложная и работает долго. Для нее используется кеш-память.
	* Она состоит из нескольких пар аргумента (X) и функции (Y), к каждой паре можно обратиться по ключу
	* Первый раз схема будет работать медленно, но он ее занесет в кеш. Тогда последующие обращения (А ОНИ БУДУТ) гораздо быстрее.
	* Проблема в том, что кеш-память меньше ОЗУ. По итогу придем к тому, что она заполнено, а записать туда еще надо. Поэтому в качестве контры используется стратегия замещения в соответствии со стратегией LFU