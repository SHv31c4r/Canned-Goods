### Кен Томпсон
* Создал UNIX в 1971 году
* Создал Go в 2009
* В общей сложности создал 4 ОС (среди них был и )

### Опять немного истории
* Со временем у Microsoft появилась возможность нанимать очень много сотрудников
* По итогу они переросли IBM
* Одна из потерь 

### OS/2
Было у нее много версий:
	1. OS/2-1 первая версия, разрабатывалась совместно с Microsoft
	2. OS/2-2 (WARP) - разработка IBM, получила высокое распространение среди ВС США. Главное удобство - система была многопользовательской и безопасной. С другой стороны - была крайне избыточной
	3. OS/2-2 (Windows NT) - разработка Microsoft, велась параллельно с WARP. От нее уже и пошли все прочие версии Windows.

### Про аккаунты
**[[MortyD14/Открытые системы/Лекция 4#БАЗОВЫЕ ПОНЯТИЯ|СМОТРИ В ПРЕДЫДУЩЕЙ ЛЕКЦИИ]]** 

### Про процессы
* Процессы - вычисления, которые инициализируются программами или пользователями.
* Все процессы имеют идентификаторы (PID). В UNIX-системах принята отличная от других система порождения процессов.
* Новый процесс порождается другим процессом, поэтому у процесса появляется еще один параметр - PPID (Parent PID~~R~~)
	* Например, у программы для входа в аккаунты PPID - это PID системы, а после нее запустилась программа-пользователь, PPID которой - это PID программы для входа в аккаунты.
* В дескрипторе процесса еще хранятся UID (запустившего), GID (, которой принадлежит запустивший), "эффективные UID"и "эффективные GID"
	* Эффективные UID и GID берутся у файла программы, которая запустилась. Поэтому "эффективные" и "обычные" могут отличаться

### Процесс запуска процессов на примере
1. Пусть мы работаем в `shell`. У него PID=745 и PPID=1 (он был запущен init'ом, который нынче `SYSTEMD`). В нем выполняется функция `fork()` - она запускает другой процесс (вернет 0, если запуск провалился или PID запущенного процесса) По итогу запустился новый `shell` с PID=802 (первый свободный PID) и PPID=745
2. В момент запуска второго `shell` делается снимок стартового  `shell`, чтобы указать его PID как PPID порожденногою
3. После запуска нового `shell` старый получил его PID как ответ от команды `fork()`. Он может как грохнуть своего сына (если он завис) или зависнуть сам на время его работы.
4. В это время второй `shell` выполняет какую-то команду, например, `ls` (его PID и PPID такие же, как и у второго `shell`). Он ее выполняет.
5. После ее выполнения вторым `shell` выполняется команда `exit`. Второй `shell` вместе со своей командой.
6. Теперь снова работает наш родительский `shell`

# МЫ ДОЛЖНЫ ВЕРНУТЬСЯ К ФАЙЛАМ (на некст лекции)