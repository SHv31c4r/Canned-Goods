*продолжаем с команды `mount` и структуры памяти*

* С помощью `mount` можно так же получить доступ к сетевому каталогу.
* Для этого есть два вида сетевых файловых систем - NFS (Network FileSystem) и SMB ()
	* Изначально, SMB - Send Message Box (для обмена сообщениями с сервером). Он разработан IBM и раньше имел название SaMBo (нынче он SMB-протокол).
	* SMB имеет и серверную, и клиентскую части

* Поэтому, в `mount` в параметре `-t` (ручное указание файловой системы) указывается или SMB, или NFS. После пишется `IP-адрес:/*полный путь к каталогу и его содержимому*` (путь должен, по идее, проходить через каталог `srv`, т.к. он и предназначен для файлов с общим доступом) и уже после указывается, как именно он у нас отображаться будет (например, `/mnt/net/srv1`)
	* Да, если мы подключаем какие-то серверные носители, то их правильнее располагать в каталоге `net` внутри `/mnt`

# Уровни выполнения

После загрузки ядра в Windows грузятся службы (в Linux это демоны) - системное программное обеспечение, которое запускается в соответствии с конфигурацией. В одних конфигурациях могут быть одни службы, в одних - другие. Могут быть даже быть разные конфигурации самих служб.
	* Проблема лишь в том, что для некоторых служб нужны другие службы в определенных конфигурациях.
	* Есть такая программа  - init (в случае с Linux). Она как раз и запускает демонов в соответствии с их уровнями иерархии: сначала запускается первый "эшелон", потом второй итд

В `/etc` есть каталог `init.d`, в котором и прописываются конфигурации, причем уровней выполнения где-то 7 уровней выполнения, где-то 10. Мы будем рассматривать систему на 7 уровнях выполнения.
	* Для определения нашего уровня выполнения можно дать команду `runlevel`
	* По умолчанию, в Linux указывается дефолтный уровень выполнения (он для клиента равен 5, а для сервера - 3)
	* Если мы захотим перейти на 0 уровень выполнения, то будем посланы нахуй самим компом, потому что он выключится. 0 уровень для этого и используется. Прикол в том, что для начала должны выключиться все используемые программы (так что и в запуске, и в завершении программ и служб должен быть порядок). Для старта службы используется команда `s` (start), для завершения - команда `kill`.
	* Проблема как раз еще и в том, что из-за требовательности к последовательности запусков сам процесс был долгим. В Microsoft сообразили, что пользователю впадлу ждать, поэтому для загрузки системы придумали регистр. Он помогал осуществлять асинхронный запуск всех указанных компонентов. Какие-то поднимутся сразу, а какие-то - даже после загрузки основы ОС и рабочего стола, например.
	* В Linux аналогом регистров стал файл SYSTEMD. Причем запуск стал логироваться. Но н все равно был последовательности.


Описание всех Runlevel:
0. Runlevel 0 = poweroff.target (runlevel0.target) - уровень для выключения системы
1. Runlevel 1 = rescue.target (runlevel1.target) - раньше он был режимом одного пользователя (single user mode)
2. Runlevel 2 = multi-user.target (runlevel2.target) - многопользовательский режим. Но он может быть и не задействован. Раньше в Mint именно тут и работал многопользовательский режим, но он переехал. Прикол режима в том, что этот режим работает и без графики. Тут нет сетевой поддержки
3. Runlevel 3 = multi-user.target (runlevel3.target) - многопользовательский режим с поддержкой сети и сетевого подключения.
4. Runlevel 4 = multi-user.target (runlevel4.target) - многопользовательский режим зачастую не определен.
5. Runlevel 5 = graphical.target (runlevel5.target) - режим работы в графической оболочке (причем этот режим так же многопользовательский)
6. Runlevel6 = reboot.target (runlevel6.target) - режим перезагрузки системы. (`shutdown`, который можно так же использовать для перезагрузки системы - это скрипт, который работает с  этим runlevel)
	А почему `target`?
	* А потому что target - это группа unit'ов. Unit - это файл, описывающий службу, которая запускается SYSTEMD. В нем описывается, что нужно для работы этой службы.
	* А наши runlevel удобно ассоциировать с target, так как суть у них одна и та же

# В следующий раз будем детально рассматривать systeemd