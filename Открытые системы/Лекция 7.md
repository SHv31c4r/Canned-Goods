## Про права доступа
В общей сложности у файла есть 12 атрибутов для определения доступа к файлам (остальные атрибуты были рассмотрены в [[MortyD14/Открытые системы/Лекция 6#Про атрибуты|предыдущей лекции]])
Часть из них относится к правам доступа:
1. r (Read) - право на чтение файла
2. w (Write) - право на запись файла (оно же у нас реализует и право на удаление данного файла)
3. x (eXecute) - право на выполнение (запуск) данного файла

Рядом с этими атрибутами всегда идет и вторая буква, указывающая на то, кому эти функции с файлами доступны:
1. u (User) - доступы для владельца фала
2. g (Group) - доступы для группы, которой принадлежит владелец
3. o (Other) - доступы для всех остальных пользователей

Есть еще особые атрибуты:
1. sU (setUID) - UID владельца данного файла.
	* Примечание: если пользователю дан какой-либо доступ к данному файлу, то фактически он работает с этим файлом от лица создателя
2. sG (setGID) - GID владельца данного файла
3. t-атрибут - это специальный sticky-bit
	* Изначально в UNIX-системах не было страничной сегментации памяти. Этот бит использовался при обращении одной программы к другой. Такая программа освобождалась от свапинга
	* Когда же страничная сегментация была добавлена, этот бит стал использоваться для запрета на удаление файла. Из-за него всю манипуляцию с каталогом мог осуществлять только владелец каталога или root.
	* Пока файл принадлежит тебе, ты можешь спокойно менять и его sticky-bit. В ином случае - только от имени root`а

**Общий порядок этих атрибутов доступа:**
`sU|sG|t|rU|wU|xU|rG|wG|xG|rO|wO|xO`

Вообще, комбинации битов могут быть любыми. А эти биты читаются слева направо, поэтому доступ будет читаться по первому биту, который и может определить доступ (например, в sG у нас нет прав доступа от группы пользователя, но в rG, wG и xG они будут указаны. Тогда и у группы будут соответствующие доступы)
	* В Linux при выполнении команды `ls -l` в первой колонке выводятся как раз права доступа. Исключением является только самый первый символ. Он указывает на тип файла (см. таблицу)
	* А после уже идут по порядку все атрибуты доступа (если он есть, то есть и соответствующий символ. Иначе - прочерк)
	* В следующей колонке идет счетчик жестких ссылок. Пока он не равен 0, файл существует
	* Третья колонка - логин владельца
	* Четвертая колонка - имя главной группы владельца
	* Пятая колонка - размер файла в байтах
		* Если файл является каталогом, то у него будет базовый размер 4к (4096 байт)
		* При заполнении данного каталога его размер будет увеличиваться кратно 4к
	* Шестая колонка - дата и время создания файла
	* Последняя колонка - имя файла

| Типы файлов           | Символ обозначения | Назначение                                                                                                                                                                                                                          |
| --------------------- | ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Обычный файл          | `-`                | Хранение символьных и двоичных данных                                                                                                                                                                                               |
| Каталог               | `d`                | Организация доступа к файлам                                                                                                                                                                                                        |
| Символьные ссылки     | `l`                | Представление доступа к файлам с любых носителей                                                                                                                                                                                    |
| Блочные устройства    | `b`                | Предоставление интерфейса для взаимодействия с апаратным взаимодействием ПК                                                                                                                                                         |
| Символьные устройства | `c`                | То же самое, что и блочные устройства, только в символьном виде                                                                                                                                                                     |
| Каналы (pipe)         | `p`                | Организация взаимодействия процессов внутри ОС.<br>* Канал работает по принципу FIFO, причем для их использования процессы должны порождаться одним родителем<br>* Сколько требуется их, столько их и создается<br>* При завершении |
| Сокеты                | `s`                | Организация взаимодействия процессов между устройствами                                                                                                                                                                             |

**Примечание про имя файла:**
	* Строгий запрет есть только на "/", "\*" и "?" (последние два - символы для регулярных выражений, они просто все сломают к хуям, если будут в имени файла)
	* Символы " " (пробел), ";", "\\" являются нежелательными, но их можно использовать
	* Ну и рекомендуется начинать имя файла с буквы

umask - переменная, которая указывает, какие права нужно ОТНИМАТЬ при создании фала
	* По факту - функция, которая указывает какие атрибуты доступа будут у нового созданного файла по умолчанию
	* Забавный факт - на каталогах у нас полные права (код 777)
		* Интерпретация прав на каталог почти такая же, как и на обычный файл. Разница лишь в праве на выполнение: это право на открытие каталога для просмотра.
		* В случае с файлом у нас права по умолчанию (код 666), т.е. разрешается чтение и выполнение, но не запись.
	* **В `umask` если мы впишем 777, то мы тупо заблокируем файл для всего.** Так что если мы так проебались, то просто редачим права через `chmod`. Если мы хотим поменять владельца, то используем команду `chown`. %%и не ебем себе мозги%%
	* Если мы хотим спиздить чужой файл себе, то команду `chown` выполняем от суперпользователя