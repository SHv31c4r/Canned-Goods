Еще на этапе генерации ОС должны собраться программы `Аппаратного контроля` (они же драйверы). Осуществляется определение количества устройств, их типа итд. 
1. Программы аппаратного контроля пишутся на ассемблере, хотя зачастую его быстрее написать на C, который поддерживает ассемблерные вставки, что удобно для тех элемента
2. С аппаратным контролем работает части: подсистема ввода/вывод и подсистема управления процессами ([[MortyD14/Операционные системы/Лекция 3|он же диспетчер задач]])
3. С двумя новыми частями работает файловая подсистема.
	* Все можно рассматривать как файлы. Файловая подсистема является благодаря этому важной частью  
4. С Файловой подсистемой и диспетчером задач уже работает Интерфейс системных вызовов (он же shell, внешняя оболочка).
	Shell не зависит от ОС, он может быть заменен вне зависимости от ядра.
5. И вот уже через Shell с ОС взаимодействуют процессы

## Пометка про стандарты
* Для UNIX систем писались разные API, которые могли меняться от системы к системе. Решили их стандартизировать. Поэтому пришли к созданию POSIX.
* Потом все равно решили писать свои API, но изначально даже они поддерживали POSIX API. Потом (до недавнего времени, щас WIN11 спокойно может запускать программы с Linux).
* Программы взаимодействуют с операционной средой, которые инициализируются ОС. Прикол в том, что ОС может создавать несколько разных операционных сред (например, Win32.API или Win64.API).
	* Microsoft не выкладывает спецификации для этих API, но есть в общем доступе интерфейсы для взаимодействия с ними.
	* Операционная среда, получается по сути, - это способность поддерживать взаимодействие с той или иной API

Все стандарты POSIX (надо бы это оформить в виде таблицы)
![[Pasted image 20250923095720.png]]

ВО:

| Стандарт | ISO Стандарт | Краткое описание                                                                                                                                                                                                                                                                               |
| -------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| POSIX.0  | Нет          | Введение в стандарт открытых систем. Не является стандартом в чистом виде, но является перечнем рекомендаций и кратким обзором технологий                                                                                                                                                      |
| POSIX.1  | Да           | Система API и язык C                                                                                                                                                                                                                                                                           |
| POSIX.2  | Нет          | Оболочки и утилиты, одобренные IEEE                                                                                                                                                                                                                                                            |
| POSIX.3  | Нет          | Тестирование и верификация                                                                                                                                                                                                                                                                     |
| POSIX.4  | Нет          | Определение задач и систем реального времени (ни Win, ни Linux таковыми не являются), треды (нити/потоки)                                                                                                                                                                                      |
| POSIX.5  | Да           | Использование языка ADA*, применительно к стандарту POSIX.1                                                                                                                                                                                                                                    |
| POSIX.6  | Нет          | Системная безопасноть                                                                                                                                                                                                                                                                          |
| POSIX.7  | Нет          | Администрирование системы                                                                                                                                                                                                                                                                      |
| POSIX.8  | Нет          | Сети с "прозрачным" доступом к файлам. Суперкомпьютер тогда (да и сейчас) делался из нескольких компьютеров.<br>Абстрактные сетевые интерфейсы (как раз, например, для создания суперкомпьютеров), не зависящих от физических протоколов.<br>Связь системы с протокол-зависимыми приложениями. |
| POSIX.9  | Да           | Использование языка Fortran, применительно к стандарту POSIX.1                                                                                                                                                                                                                                 |
| POSIX.10 | Нет          | Super-computing Application Profile (Профиль как совокупность стандартов для решения задач {использовать не все стандарты, а только необходимые, и их надо согласовывать}) (AEP)                                                                                                               |
| POSIX.11 | Нет          | Обработка транзакций AEP (Транзакция - законченная операция, завершается получением ответа)                                                                                                                                                                                                    |
| POSIX.12 | Нет          | Графический интерфейс пользователя (GUI). Общепринятым считается OpenGUI, хотя Microsoft пошла дальше                                                                                                                                                                                          |
**ПРИМЕЧАНИЯ**:
* ADA - это язык, который был создан в честь Ады Лавлейс - женщины-математика, которая описала реальную версию вычислительной машины; этот язык является языком реального времени. Он применялся ВС США для разработки QNX-систем
* QNX - система реального времени. Такие системы стоят на изделиях воздух-твое_ебало

## Характеристики POSIX-систем (UNIX-подобных)

#### БАЗОВЫЕ ПОНЯТИЯ:
1. Образ и виртуализация вычислений:
	* Когда первая UNIX-система стала многопользовательской, стало необходимым создавать некий виртуальный компьютер для работы для конкретного пользователя
	* Такой виртуальный компьютер забирал себе долю аппаратной части для себя
	* SPOOLing (Simultaneous Peripherial Operation Off-Line). С этой штукой мы работаем по кд. Например, печать файла на принтере. Файл конвертируется в код, который и будет напечатан.  SPOOLing, грубо говоря, формирует специальный SPOOL-файл, в котором и закодированы данные для печати. И этот файл уже передается как код
	* Под образом подразумевается... Он состоит из трех подобразов:
		1. Подобраз реинтерабельных виртуальных программ
		2. Подобраз данных. Область для переменных из реинтерабельных программ
		3. Образ стека. Для динамических данных. Нужно, чтобы он не затирал другие данные, иначе будет плохо.
	* При нехватке ОЗУ происходит процедура SWAPPING
	* От образного расположения решили отказаться, перешли на страничный тип (Paging)
		* В некоторых случаях требуется взаимодействие нескольких процессов. Для этого можно попросить у ОС те или иные данные в досутп.
2. Процесс
	* Процессы в UNIX-системах могут делиться на привилегированные и непривилегированные.
	* Процессы могут быть интерактивными и неинтерактивными. Неинтерактивные процессы - это демоны (программные коды, к которым обращаются только ОС для расширения своего функционала)
	* Короче, пиздуй читать про понятия процесса с открытых систем
3. Файл
	* Файл в UNIX-системах не имеет имени.  Для поиска файла (в связи с малым количеством ресурсов) было принято давать числовые идентификаторы (как для процессов: PID - Process ID). Их назвали I-node (Inode).
	* С точки зрения пользователя удобнее использовать имена файлов, а не I-node. Для связи между именами и I-node'ами используются директории.
	* В Microsoft решили хранить имя файла в самом файле. Для ориентирования использовались дескрипторы. И пока этих файлов мало, то все гуд.
	* Так пришли к каталогизации уже самих каталогов (для этого использовались дескрипторы более высокого уровня).
	* I-node'ы создаются во время форматирования диска, и имеют ID начиная с 2. Для более сложной структуризации (по каталогам) также используются дескрипторы.
	* Файлы описываются I-node'ами:
		1. Главное поле - идентификатор
			Файлы в рамках каталога для поиска перебираются. Но в некоторых файловых системах поиск файла осуществляется алгоритмически (например, поиск I-nod'а при помощи хеширования имени файла)
		2. Counter (счетчик) - счетчик имен у файла.
			Количество имен у файла ограничено максимальным значением счетчика, но удачи до этого предела дойти.
			Фактически, файл не удаляется до тех пор, пока счетчик не упадет до 0. Тогда по данному I-nod'у будет фиксироваться новый файл.
		3. Владелец (Owner) 
			* Есть понятие Creator-Owner (кто создал, тот и хозяин), но файл можно подарить
			* Суперпользователь (админ) может это поле как угодно менять
		4. Дата и время создания файла
		5. Дата и время изменения файла
		6. Дата и время последнего открытия файла
		7. Информация о кластерах, где расположен файл. Можно указывать и блок описателей (но это для больших файлов)
	* **Любое изменение файла сопровождается изменением содержимого I-nod'а** 
4. Аккаунт (учетная запись)
	* У пользователя есть идентификатор (UID). Система с ними и работает
	* GID (Group ID) - группы пользователей. Это позволяет давать доступ по принципу группы, что удобно
