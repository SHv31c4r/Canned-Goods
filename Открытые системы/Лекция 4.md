Еще на этапе генерации ОС должны собраться программы `Аппаратного контроля` (они же драйверы). Осуществляется определение количества устройств, их типа итд. 
1. Программы аппаратного контроля пишутся на ассемблере, хотя зачастую его быстрее написать на C, который поддерживает ассемблерные вставки, что удобно для тех элемента
2. С аппаратным контролем работает части: подсистема ввода/вывод и подсистема управления процессами ([[MortyD14/Операционные системы/Лекция 3|он же диспетчер задач]])
3. С двумя новыми частями работает файловая подсистема.
	* Все можно рассматривать как файлы. Файловая подсистема является благодаря этому важной частью  
4. С Файловой подсистемой и диспетчером задач уже работает Интерфейс системных вызовов (он же shell, внешняя оболочка).
	Shell не зависит от ОС, он может быть заменен вне зависимости от ядра.
5. И вот уже через Shell с ОС взаимодействуют процессы

## Пометка про стандарты
* Для UNIX систем писались разные API, которые могли меняться от системы к системе. Решили их стандартизировать. Поэтому пришли к созданию POSIX.
* Потом все равно решили писать свои API, но изначально даже они поддерживали POSIX API. Потом (до недавнего времени, щас WIN11 спокойно может запускать программы с Linux).
* Программы взаимодействуют с операционной средой, которые инициализируются ОС. Прикол в том, что ОС может создавать несколько разных операционных сред (например, Win32.API или Win64.API).
	* Microsoft не выкладывает спецификации для этих API, но есть в общем доступе интерфейсы для взаимодействия с ними.
	* Операционная среда, получается по сути, - это способность поддерживать взаимодействие с той или иной API

Все стандарты POSIX (надо бы это оформить в виде таблицы)
![[Pasted image 20250923095720.png]]

ВО:

| Стандарт | ISO Стандарт | Краткое описание                                                                                                                                                                                                                                                                               |
| -------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| POSIX.0  | Нет          | Введение в стандарт открытых систем. Не является стандартом в чистом виде, но является перечнем рекомендаций и кратким обзором технологий                                                                                                                                                      |
| POSIX.1  | Да           | Система API и язык C                                                                                                                                                                                                                                                                           |
| POSIX.2  | Нет          | Оболочки и утилиты, одобренные IEEE                                                                                                                                                                                                                                                            |
| POSIX.3  | Нет          | Тестирование и верификация                                                                                                                                                                                                                                                                     |
| POSIX.4  | Нет          | Определение задач и систем реального времени (ни Win, ни Linux таковыми не являются), треды (нити/потоки)                                                                                                                                                                                      |
| POSIX.5  | Да           | Использование языка ADA*, применительно к стандарту POSIX.1                                                                                                                                                                                                                                    |
| POSIX.6  | Нет          | Системная безопасноть                                                                                                                                                                                                                                                                          |
| POSIX.7  | Нет          | Администрирование системы                                                                                                                                                                                                                                                                      |
| POSIX.8  | Нет          | Сети с "прозрачным" доступом к файлам. Суперкомпьютер тогда (да и сейчас) делался из нескольких компьютеров.<br>Абстрактные сетевые интерфейсы (как раз, например, для создания суперкомпьютеров), не зависящих от физических протоколов.<br>Связь системы с протокол-зависимыми приложениями. |
| POSIX.9  | Да           | Использование языка Fortran, применительно к стандарту POSIX.1                                                                                                                                                                                                                                 |
| POSIX.10 | Нет          | Super-computing Application Profile (Профиль как совокупность стандартов для решения задач {использовать не все стандарты, а только необходимые, и их надо согласовывать}) (AEP)                                                                                                               |
| POSIX.11 | Нет          | Обработка транзакций AEP (Транзакция - законченная операция, завершается получением ответа)                                                                                                                                                                                                    |
| POSIX.12 | Нет          | Графический интерфейс пользователя (GUI). Общепринятым считается OpenGUI, хотя Microsoft пошла дальше                                                                                                                                                                                          |
**ПРИМЕЧАНИЯ**:
* ADA - это язык, который был создан в честь Ады Лавлейс - женщины-математика, которая описала реальную версию вычислительной машины; этот язык является языком реального времени. Он применялся ВС США для разработки QNX-систем
* QNX - система реального времени. Такие системы стоят на изделиях воздух-твое_ебало

## Характеристики POSIX-систем (UNIX-подобных)

#### БАЗОВЫЕ ПОНЯТИЯ:
1. Образ и виртуализация вычислений:
	* Когда первая UNIX-система стала многопользовательской, стало необходимым создавать некий виртуальный компьютер для работы для конкретного пользователя
	* Такой виртуальный компьютер забирал себе долю аппаратной части для себя
	* SPOOLing (Simultaneous Peripherial Operation Off-Line). С этой штукой мы работаем по кд. Например, печать файла на принтере. Файл конвертируется в код, который и будет напечатан.  SPOOLing, грубо говоря, формирует специальный SPOOL-файл, в котором и закодированы данные для печати. И этот файл уже передается как код
	* Под образом подразумевается... Он состоит из трех подобразов:
		1. Подобраз реинтерабельных виртуальных программ
		2. Подобраз данных. Область для переменных из реинтерабельных программ
		3. Образ стека. Для динамических данных. Нужно, чтобы он не затирал другие данные, иначе будет плохо.
	* При нехватке ОЗУ происходит процедура SWAPPING
	* От образного расположения решили отказаться, перешли на страничный тип (Paging)
		* В некоторых случаях требуется взаимодействие нескольких процессов. Для этого можно попросить у ОС те или иные данные в досутп.
2. Процесс
	* Процессы в UNIX-системах могут делиться на привилегированные и непривилегированные.
	* Процессы могут быть интерактивными и неинтерактивными. Неинтерактивные процессы - это демоны (программные коды, к которым обращаются только ОС для расширения своего функционала)
	* Короче, пиздуй читать про понятия процесса с открытых систем
3. Файл
	* Файл в UNIX-системах не имеет имени.  Для поиска файла (в связи с малым количеством ресурсов) было принято давать числовые идентификаторы (как для процессов: PID - Process ID). Их назвали I-node (Inode).
	* С точки зрения пользователя удобнее использовать имена файлов, а не I-node. Для связи между именами и I-node'ами используются директории.
	* В Microsoft решили хранить имя файла в самом файле. Для ориентирования использовались дескрипторы. И пока этих файлов мало, то все гуд.
	* Так пришли к каталогизации уже самих каталогов (для этого использовались дескрипторы более высокого уровня).
	* I-node'ы создаются во время форматирования диска, и имеют ID начиная с 2. Для более сложной структуризации (по каталогам) также используются дескрипторы.
	* Файлы описываются I-node'ами:
		1. Главное поле - идентификатор
			Файлы в рамках каталога для поиска перебираются. Но в некоторых файловых системах поиск файла осуществляется алгоритмически (например, поиск I-nod'а при помощи хеширования имени файла)
		2. Counter (счетчик) - счетчик имен у файла.
			Количество имен у файла ограничено максимальным значением счетчика, но удачи до этого предела дойти.
			Фактически, файл не удаляется до тех пор, пока счетчик не упадет до 0. Тогда по данному I-nod'у будет фиксироваться новый файл.
		3. Владелец (Owner) 
			* Есть понятие Creator-Owner (кто создал, тот и хозяин), но файл можно подарить
			* Суперпользователь (админ) может это поле как угодно менять
		4. Дата и время создания файла
		5. Дата и время изменения файла
		6. Дата и время последнего открытия файла
		7. Информация о кластерах, где расположен файл. Можно указывать и блок описателей (но это для больших файлов)
	* **Любое изменение файла сопровождается изменением содержимого I-nod'а** 
4. Аккаунт (учетная запись/учетка, но где-то используется термин бюджет, что по смыслу тупо)
	* У пользователя есть идентификатор (UID). Система с ними и работает. Этот UID является, по сути, локальным для каждой системы
	* Аккаунт был обязателен для работы с системой, чтобы нормально выделять этому самому пользователю виртуальные мощности
		Тут использовались два новых понятия:
		* log in (впоследствии login)
			Раньше такое журналирование было без пароля (кто угодно мог зайти в твой акк), поэтому появилось еще понятие пароля (password)
		* log on - журнал, который учитывал, какой пользователь зашел, сколько работал итд. Удобно отслеживать, чтоб люди платили за использование мощностей.
		* Раньше пользователей определяли 16-битным ID, но на смену ему в Windows пришел UUID (размером 128-бит), что дает гарантированную уникальность ID в рамках локальной машины
		* Если же смотреть в рамках условного сервера, то пересечение возможно. Тогда он определялся по UUID и БД одновременно. Тогда уникальность все равно обеспечивалась
		* Но в UNIX-системах это не так работает. Там использовался как раз UID
			Они начинаются с одного значения, после его использования новый UID инкрементируется
			* Очевидно, что первый UID равен 0. Это идентификатор нашего любимого суперпользователя (в Win его альтернативой является администратор). Логин такого пользователя имеет название root (и его директория является корневой /).
				* У обычного пользователя будет указан каталок `~` - обозначение именно его домашней дирректории
			* Ну и все остальные пользователи имеют положительный UID (от одного и дальше). 
			* От имени root можно сделать АБСОЛЮТНО любые действия без проверок. Ограничений нет!
				* Иногда root можно переименовать
			* В ином случае пользователь может работать только со своим файлом. Это проверяется сравнением UID пользователя-создателя (ну или владельца файла) с UID пользователя, инициировавшего процесс взаимодействия с этим файлом
	* Если же нужно было, чтобы несколько пользователей могло работать с одним файлом, то тогда шли целые списки, но это было не удобно. Для этого начали использовать группы пользователей
	* GID (Group ID) - группы пользователей. Это позволяет давать доступ по принципу группы, что удобно.
	* При создании учетки она автоматически попадает в ту или иную группу.
		* В ином случае непонятно, какие права (priveleges->permissions) были у учетки
		* permissions - множество каких-либо разрешений, которые приписываются к объектам, разным экземплярам объектов. Они прописываются в рамках групп (это касается экземпляров). В случае классов мы говорим, что у них есть какие-либо привилегии
	* Primaty Group - термин, который появился в UNIX, есть вплоть в OS/2-2 (WARP). Эта самая первичная группа (она же главная) вписывается при создании пользователя. Пользователь, который "породил" эту группу, может ею управлять, что позволяет, например, дать доступ к манипуляциям со своими файлами. Но так же можно задать группу вручную, но только при условии ее существования.
		* Группы тоже раньше имели пароли, но это было проблемой в безопасности, поэтому от паролей группы отказались
		* Так как от root можно наебнуть систему, то придумали, что будет, грубо говоря, сделать одного управляющего пользователя, но он не является суперпользователем. Для переключения на нее использовалась команда `su` (`switch user` или `set uid`, т.к. ты буквально мог переключиться ). Для выхода с root'а использовалась команда `exit`
		* Для отображения того, что пользователь работает как root использовался символ `#`, иначе был знак `$`. Это уже прикол для вирусов - они ничего не смогут сделать с системой, пока не зашла как root. А для этого нужен пароль.
		* Фан факт - учетка блокируется, если было 5 неудачных попыток ввода пароля. Это помогает подбирать пароль. Но root нельзя, так сказать, нокнуть путем перебора паролей - подбирай сколько хочешь, тебе пользователя не заблокируют
		* По итогу, команда su считалась небезопасной. Придумали команду `sudo` (`set uid and do exit`). Она дает статус суперпользователя, но только на одну эту самую команду. От sudo никого запускать не стоит (это касается программ). Максимум, только утилитам.
			* Чтобы sudo не выполнялся кем попало, ты должен сообщить свой пароль.
			* Для того, чтобы не каждый мог выполнять команды как суперпользователь, вводились группы, которые могли "становиться суперпользователями".
			* Еще можно было при команде указывать параметр `-i`. Тогда активировалась команда `su`.
	* В Linux'е придумали делить пользователей на три группы (изначально их две, root и обычные плебеи): root, обычные аккаунты и глобальные аккаунты.
		* Еще можно отметить аккаунты-боты (они использовались демонами). Эти боты лежат в UID от 1 до 1000 (иногда до 500). Их количество и UID могут отличаться от системы к системе.
	* У пользователей с UID > 2500 их UID становится глобальным. Их данные лежат на специальном сервере.