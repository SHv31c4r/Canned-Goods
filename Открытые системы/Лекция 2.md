* Т.к. при включении ПК нет ни шиша данных, придумали записывать двоичные коды, которые инициализируют процесс запуска системы. Для их хранения должна быть отдельная энергонезависимая память (он же BIOS)
* На замену ему пришел UEFI. 

## Процесс включения
1. При включении процессор направляется в УЖЕ УКАЗАННУЮ для него ячейку памяти, которая определена его конструктивом.
2. Начиная с этой ячейки уже и начинается взаимодействие процессора с памятью. Происходит инициализация BIOS (самотестирование).
	Забавно, что в БИОС зашивались драйвера для, так сказать, базового использования. А так остальные драйвера лежат не на флешке биоса
3. После этого идет чтение самого первого блока с диска. Там и записан СУФ. Происходит инициализация системы.
	* В процессе форматирования в этот самый блок всегда заносится блок инициализации ОС
	* Процесс форматирования был еще и низкоуровневым, он зашивался в БИОС. Он работал со всей памятью, делил ее на блоки с условием, что размер блока кратен степени 2.

...
До этого была 16-битовые коды, этого было мало, поэтому придумали делить данные на два регистра.
Самый первый блок содержит адресы для следующих файлов:
	1.  IO.sys - для управления устройствами ввода/вывода
	2. DOS.sys - файл СУФ

Для современных систем этого мало.
Операционные системы начали переводить с одних адресов (процессорных) на другие (реальные, так сказать).
#### Для этого пришел UEFI
Самый первый блок начал хранить еще файл sys, что позволило после чтения первых двух файлов читать любые другие, необходимые для инициализации системы.

Адрес программы состоит из многих ячеек. Адрес тогда стал формироваться из базы (адреса блока) и смещения (по сути, адреса внутри этого самого блока).

Ну и для работы с таким объемом памяти ее пришлось модернизировать. Изначально по дискетам (старой памятью) бегала ГСЗ, из-за чего дискеты механически портились. Теперь же крутился сам диск (он был магнитным), а ГСЗ просто опускалась и поднималась.

Объемы выросли на несколько порядков, поэтому пришлось осуществлять деление физического на логические диски. Но для отслеживания этого деления нужно было вводить стандарты, т.к. иначе было бы невозможно правильно находить и интерпретировать данные.

Был принят стандарт от IBM - ***MBR***. Этот стандарт решили сделать открытым для глобального удобства, так сказать. 
	(иронично, что IBM по итогу этих действий потеряла позиции). Они решили закрыться и разработали PS/2 (Personal System 2 поколения). Продавали на нее лицензию, но "стратка не сработала".

На смену MBR пришел GPT (его модификация).

### MBR против GPT

Обе спецификации основываются на понятии таблицы разделов - структуре данных, которая отвечает за разбиение

#### 1. MBR (Master Boot Record)

MBR - это первый сектор размером 512 байт
Структура MBR:
1. Код и данные MBR (not system boostrap) размером 446 байт
	В нем определяется какой отдел является активным (он и будет отвечать за загрузку ОС)
	* Код, находящийся там выполняет следующие действия:
		1. 
2. Таблица разделов размером 64 байта
	Содержит инфу об основных разделах. Может быть всего 4 раздела (их называют Parition). Если этого мало, то один из них можно сделать расширенным (но такой раздел не может быть загрузочным)
3. Сигнатура размером 2 байта
	Подпись/сертификат, который помогает BIOS распознать MBR как действительный. Иначе BIOS пошлет всех нахуй и обидится.
	В нем лежит код 55AAh (01011010)

AX - лучший UNIX за всю историю, который был разработан в IBM

У MBR есть неприятное ограничение. Максимальный объем может быть не более 2Тб
#### 2. GPT (GUID [Global UID] Partition Table)
* Идентификаторы являются 128-битовыми, чего достаточно для уникальной идентификации огромного до ебанутости объемов данных
* Он содержит следующие части:
	1. Protected MBR (он используется для обратной совместимости, а также, чтоб, если данные были прочитаны некорректно, то они не потерялись)
	2. Заголовок GPT - информация, сколько и каких заголовков/разделов лежат на диске. Такая же инфа хранится как бекап в конце сегмента, но оно там записано в обратном порядке.
		Там есть ограничение на количество разделов в блоке - их не более 4, и у каждого идентификатор 128 бит.
	3. Описание разделов

UEFI после самотестирования проходится по разделам GPT

