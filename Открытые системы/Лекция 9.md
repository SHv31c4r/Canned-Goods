* `chron` - планировщик задач. 
* Работает при помощи соответствующего демона.
* Его работа основана на сравнении текущего времени со временем, присвоенном процессу

* `SPOOL` (**S**imultaneous **P**eripheral **O**perations **O**n**L**ine) - технология, позволяющая временно хранить данные в очереди и освобождать процессор для выполнения других задач.
	* По сути дела - это система управления вывода. В операционках уже упоминалось, что чтоб процессор не занимать на это, за это отвечает отдельный элемент, микросхема. Вот эту же штуку можно реализовать виртуально, видимо.
	* SPOOL отвечает за весь вывод данных от всех пользователей и процессов. А данные разделяет при помощи заголовков.
	* SPOOL-файл может передаваться на прочие "принтеры" (хоть внешние, буквально принтеры)

### Про процессы
* Прикол в том, что в Linux нет как такового состояния бездействия. Состояния процессов описаны на рисунке ниже:
![[MortyD14/Photo/alse_mod13_process_lifecycle.png| ]]

* Приоритеты у процессов есть, но они строятся из двух частей: приоритета (PRI) и вежливости (NI)
	* У процессов реального времени нет вежливости
	* В общем же случае, приоритеты колеблятся от -100 до 99, причем -100 приоритет - самый высокий

Дальше идет разговор про привилегированные и пользовательские процессы. ТАк же, как и в операционках
	* Демоны - это пользовательские процессы, НЕ ПРИВЕЛИГИРОВАННЫЕ

Также есть классификации на background и foreground процессы
* Background - фоновые процессы. У них нет связи с каким-либо терминалом, который их запустил. Они работают с ядром и радуются своей изолированной жизнью
* Foreground - процессы, которые уже имеют связь с терминалами и процессами, которые их породили.

Поток/файл:
	* `stdin` (0) - поток ввода
	* `stdout` (1) - поток вывода
	* `stderr` (2) - поток для ошибок

Вот благодаря этим потокам можно писать скрипты
	* `<` - перенаправление ввода. Мы можем сами забить, откуда будет осуществляться ввод.
	* `>` - перенаправление вывода. 
	* `|` - конвейер для последовательного выполнения нескольких команд. По сути, получился скрипт
	* `&` - указывается в конце программы. Он сделает процесс foreground

## Про монтирование

* Как уже говорилось до этого, мы работаем с томами.
* На эти тома у нас есть метаданные: размер тома, размер кластера, количество занятых/свободных кластеров, какая файловая система на нем итд. И это все хранится в суперблоке. Собственно, правильнее говорить, что суперблок и создает эти данные.
* В каждом томе есть свой корневой каталог.
	* Хотя в POSIX-системах должен быть только один корень
	* Так что для их объединения была придумана операция `mount`.

#### Про команду `mount`

Она позволяет отобразить файловую систему некоторого устройства (где есть корневой каталог) на каталог, который есть в нашей корневой файловой системе. И наш корневой каталог - это `/`. 
	* Там лежит наша файловая система
	* Мы создаем физические тома на устройствах
	* Тома объединяем в группы
	* И эту группу уже разбиваем на логические тома.
	* ВАЖНО: файловую систему мы делаем именно на ЛОГИЧЕСКОМ томе