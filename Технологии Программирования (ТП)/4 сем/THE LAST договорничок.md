**1. Что такое статическое связывание в C++?**

**Ответ:** Статическое связывание — это связывание вызовов функций с их реализацией на этапе компиляции. При этом вызов функции через указатель определяется типом указателя, а не объектом, на который он указывает.

**2. Какой тип связывания используется при вызове функции через указатель, если функция не виртуальная?**

**Ответ:** Статическое связывание.

**3. Каков результат вызова функции** print() **через указатель на базовый класс, если функция не виртуальная?**

**Ответ:** Будет вызвана реализация функции из базового класса, даже если указатель ссылается на объект наследника класса.

**4. Что такое динамическое связывание и как оно реализуется в C++?**

**Ответ:** Динамическое связывание — это связывание вызовов функций с их реализацией на этапе выполнения. Оно реализуется с помощью виртуальных функций.

**5. Какое ключевое слово используется для объявления виртуальной функции?**

**Ответ:** virtual.

**6. Какой тип связывания применяется при вызове виртуальной функции через указатель?**

**Ответ:** Динамическое связывание.

**7. Может ли виртуальная функция быть определена вне класса?**

**Ответ:** Нет, ключевое слово virtual применяется только к функциям, определенным внутри класса.

**8. Что такое полиморфный класс?**

**Ответ:** Полиморфный класс — это класс, который определяет или наследует хотя бы одну виртуальную функцию.

**9. Какой тип связывания используется при вызове виртуальной функции через имя объекта?**

**Ответ:** Статическое связывание.

**10. Какие ограничения накладываются на виртуальные функции при переопределении в производном классе?**

**Ответ:** В производном классе функция должна иметь тот же набор параметров, возвращаемый тип и константность, что и в базовом классе.

**11. Для чего используется ключевое слово** override**?**

**Ответ:** Оно явно указывает, что функция переопределяет виртуальную функцию из базового класса.

**12. Что произойдет, если в производном классе функция с** override **не соответствует виртуальной функции базового класса?**

**Ответ:** Компилятор выдаст ошибку.

**13. Как запретить переопределение виртуальной функции в производных классах?**

**Ответ:** С помощью спецификатора final.

**14. Что такое абстрактный класс в C++?**

**Ответ:** Абстрактный класс — это класс, который содержит или наследует хотя бы одну чистую виртуальную функцию и не может иметь экземпляров.

**15. Какая функция называется чистой виртуальной?**

**Ответ:** Чистая виртуальная функция — это функция, которая не имеет реализации и объявляется с = 0.

**16. Как объявляется чистая виртуальная функция?**

**Ответ:** Например: `virtual double getSquare() const = 0;` 

**17.**  **Может ли абстрактный класс не содержать чистых виртуальных функций?**

**Ответ:** Нет, наличие хотя бы одной чистой виртуальной функции является обязательным условием для абстрактного класса.

**18. Что произойдет, если производный класс не переопределит чистую виртуальную функцию?**

**Ответ:** Производный класс также останется абстрактным.

**19. Каким образом абстрактные классы обеспечивают расширяемость системы?**

**Ответ:** Они позволяют добавлять новые реализации, не изменяя код, который работает с базовым абстрактным интерфейсом.

**20. Как вызвать конструктор базового абстрактного класса из производного класса?**

**Ответ:** Через список инициализации конструктора производного класса, например:
`Rectangle(int x, int y, double w, double h) : Shape{x, y}, width(w), height(h){}`

**21. Что такое шаблон функции в C++?**

**Ответ:** Шаблон функции — это конструкция, позволяющая определить функцию, которая может работать с разными типами данных.

**22. Какое ключевое слово используется для объявления шаблона функции?**

**Ответ:** template.

**23. Какой символ используется для обозначения параметра шаблона?**

**Ответ:** Обычно T, хотя можно использовать любой другой идентификатор.

**24.**  **Какие требования предъявляются к типам, используемым с шаблонами функций?**

**Ответ:** Типы должны поддерживать все операции, которые применяются к ним в теле шаблонной функции.

**25. Как компилятор определяет конкретный тип для шаблона функции?**

**Ответ:** На основе типов переданных аргументов.

**26.Каким образом шаблоны функций улучшают безопасность типов?**

**Ответ:** Они выполняют проверку типов на этапе компиляции, предотвращая несовместимые операции с типами.

**27. Как объявить шаблон функции для обмена значениями двух переменных?**

**Ответ:** Например: `template<typename T> void swap(T& a, T& b);`

**28. Какое ключевое слово используется для автоматического вывода типов в шаблонах, начиная с C++20?**

**Ответ:** auto.

**29. Как объявить шаблон класса в C++?**

**Ответ:** `template<typename T> class Person{...};` 

**30. Какие ключевые слова могут использоваться для обозначения параметров шаблона класса?**

**Ответ:** `typename` или `class`.

**31.**  **Какие виды параметров могут быть у шаблонов классов?**

**Ответ:** Типовые параметры (typename/class), нетиповые параметры и шаблонные параметры.

**32. Как компилятор обрабатывает шаблон класса при создании объектов с разными типами?**

**Ответ:** Для каждого набора типов создается отдельная версия класса.

**33.Какие элементы класса могут зависеть от параметров шаблона?**

Ответ: Типы полей, параметры методов, базовые классы и размеры массивов.

**34.Какие проблемы могут возникнуть при использовании шаблонов классов?**

**Ответ:** Увеличение времени компиляции, сложность диагностики ошибок и увеличение размера кода.

**35. Какие типы данных можно использовать для параметров шаблона класса?**

**Ответ:** Любые, включая встроенные типы, пользовательские классы, указатели и ссылки

**36.Каково основное применение шаблонов классов в современном C++?**

**Ответ:** Создание универсальных, эффективных и типобезопасных контейнеров и алгоритмов.

**37. Как шаблон класса обрабатывает разные типы данных для полей?**

**Ответ:** Для каждого типа создается отдельная версия класса.

**38. В чем разница между шаблоном функции и шаблоном класса?**

**Ответ:** Шаблон функции определяет функцию для разных типов, а шаблон класса — целый класс.

**39. Можно ли использовать шаблоны для массивов или указателей?**

**Ответ:** Да, например:
`template<typename T> void processArray(T* arr, int size)`

**40. Какой вывод будет, если передать в шаблон функции типы, не поддерживающие операцию сложения?**

**Ответ:** Компилятор выдаст ошибку, так как операция не определена для этих типов.