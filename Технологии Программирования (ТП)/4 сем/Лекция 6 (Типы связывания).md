
При вызове функции компилятор должен соотнести имя функции с ее реализацией. Для этого используется 2 типа связывания - статическое (раннее) и динамическое (позднее).

## Статическое связывание
- Вызов функции соотносится с ее реализацией на этапе компиляции.
- Например, если в родителе и наследнике есть полностью одинаково объявленная функция, то будет выполняться функция именно из родителя

## Динамическое связывание
- Позволяет выбирать в процессе выполнения, какую функцию использовать.
- Для этого используют виртуальные функции (такие функции помечаются словом `virtual`)
- Функцию можно сделать виртуальной прямо в классе. Тогда у наследника можно самостоятельно задать собственную реализацию, т.е. переопределить
- Класс, наследующий или переопределяющий виртуальную функцию,  называется полиморфным

## Особенности использования
- Функцию со статическим связыванием можно вызвать напрямую
- Динамическое идет строго через указатель

## Override 
- Можно использовать для переопределения функции
- Пишется в классе-наследнике

## final
- Определяет, что эту функцию переопределить нельзя в наследнике

## Абстрактные классы и виртуальные функции
- Абстрактный класс - это класс, который используется для организации иерархии классов.
- Он всегда будет родителем
- Определяет общую структуру наследников (например, класс car, а его наследники truck, pickup и тд)
- Абстрактный класс содержит хотя бы одну ==чисто виртуальную функцию== 
- Никто не запрещает использовать в абстрактном классе поля, методы, конструкторы и деструкторы, но они тогда должны быть общими для всех наследников

- Чисто виртуальная функция - функция без определения (есть заголовок, но нет тела). 
- Цель таких функций - определить функционал наследников.
- Чтобы сделать функцию чисто виртуальной, нужно после заголовка поставить ``= 0`` 

## Шаблоны
- Шаблон - определение конструкции, которые используются для определенных типов данных, но тип этих данных заранее не определить.
- Например, можно просуммировать все элементы массива, причем если через шаблон просуммировать массив чисел, то мы получим значение суммы, а если массив символов - то строку
- Оформляется он примерно так: `template<typename T> T sum(T a, T b);`  

- Начиная с C++ 20 можно использовать ключевое слово auto - автоматически определить тип данных по присеваемому значению (собственно, его тип он и возьмет)

- Можно сделать и шаблон класса. Это позволит использовать внутри классов объекты с заранее неизвестным типом данных
- Оформить можно так:
	`template <typename [вставьте свои названия типов данных]>`
	`class Pupupu{`
	`//тело класса`
	`};`
