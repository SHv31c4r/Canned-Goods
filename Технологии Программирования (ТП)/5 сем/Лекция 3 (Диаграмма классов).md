- Класс - совокупность общих признаков группы объектов
- Экземпляр класса - объект
- Атрибут класса — существенная с точки зрения решаемой задачи характеристика реального или абстрактного предметы
- Отношение классов — постоянная во времени связь между классами
- Графическое обозначение класса — прямоугольник. Можно использовать несколько вариантов, отличающиеся степенью детализации

Оформление класса в UML:
[](Photo/Pasted image 20250929201313.png)
![[Pasted image 20250929201313.png]]

"+"  - обозначение public атрибута/функции
"#"  - обозначение protected атрибута/функции
"-"  - обозначение private атрибута/функции (если ничего не указано, то оно такое по умолчанию)
* *если класс абстрактный - то его название пишется курсивом*

Типы отношений между классами:
[](Photo/Pasted image 20250929202045.png)
![[Pasted image 20250929202045.png]]

### Классификация отношений:
1. Ассоциация
	Ассоциация - это структурная связь между элементами модели, которая описывает набор связей, существующих между объектами. Ее используют в том случае, когда остальные типы отношений неприменимы к описанию их взаимоотношений
	Ассоциации бывают следующих видов:
		1. Бинарная
		2. N-арная
		3.  Агрегации и композиции
			* Это связи целого с его частями (по сути, это связь "состоит из")
			* В случае с агрегацией целое и его части существуют независимо, при уничтожении целого  его части не меняются
			[](Photo/Pasted image 20250929203224.png)
			![[Pasted image 20250929203224.png]]
			* В случае с композицией существование целого и его частей зависимо, при уничтожении целого уничтожаются и его части
			[](Photo/Pasted image 20250929203322.png)
			![[Pasted image 20250929203322.png]]

2. Обобщение
	* Обобщение по сути равно наследованию. *Родитель "обобщает" всех детей, т.к. дети берут все его признаки*
	[](Photo/Pasted image 20250929203527.png)
	![[Pasted image 20250929203527.png]]

3. Реализация
	* Реализация - это когда один из классов является интерфейсом, а второй - его определенным наследником.
	* Интерфейс - класс, который не содержит реализации методов и, уж тем более,  КАКИХ-ЛИБО АТРИБУТОВ. (Получается, интерфейс = абстрактный класс)
	* Треугольник указывает на поставщика (интерфейс):
	![[Pasted image 20250929203919.png]]

4. Зависимость
	* Зависимость - вид связи, при которой один класс является параметром метода другого класса (один класс пользуется данными/методами другого, не являясь его частью)
	* Стрелка направлена на ту сущность, у которой пиздят данные/методы 
	![[Pasted image 20250929204323.png]]

Пример диаграммы классов:
![[Pasted image 20250929204346.png]]

# Часть два

Диаграмма классов может рисоваться с разной степенью подробности: даже тупо названия можно - все равно схаваем и добавки попросим

Про методы: придумать, но в любом раскладе можно префом написать конструкторы, сеттери и геттеры.

Пример из кода:
![[Pasted image 20251013202754.png]]
Примечание:
	Для реализации агрегации и композиции должны быть указатели на соответствующие классы. Разница их идет в процессе использования в рамках кода: 
	![[Pasted image 20251013203034.png]]
	Композиция задается через `new` , для того, чтобы оно, как раз, удалялось, вместе со своим целым. "Кусок создается вместе со своим целым, и вместе с ним удаляется"
	Агрегация же требует прямое присвоение (поэтому оно и требует более "слабой реализации", т.к. ) Тогда и кусок сможет существовать даже при отсутствии целого

Реализация зависимости (да, тупо используем этот класс в рамках другого класса)
![[Pasted image 20251013203440.png]]

Содержимое `main()`
![[Pasted image 20251013203603.png]]
![[Pasted image 20251013203635.png]]
![[Pasted image 20251013203647.png]]

* N-арная ассоциация не используется в программировании
* Поэтому будет рассматриваться только бинарная ассоциация
	**Если ничем другим отношения между классами нельзя описать, то эти классы относятся друг к другу в соответствии с бинарной ассоциацией**

При обобщении (наследовании) в диаграмме классов у потомка НЕ НАДО указывать родительские методы и атрибуты. Они и так по умолчанию там сидят и не рыпаются

1. Ассоциация
	* ***Ассоциация** – показывает наличие смысловой связи между классами
	* _Ассоциация_ как _связь_ между классами обязательно переходит в _связь_ между экземплярами этих классов. 
	* _Ассоциации_ в программном коде могут быть реализованы, например, через атрибуты-указатели языка C++

Бинарная ассоциация:
	Тут нет таких ограничений как в реляционной БД. Бинарная ассоциация может быть как 1:1, так и 1:М
	Пример связи 1:1 (у каждого сотрудника есть только один cardID) и связи 1:M (каждый сотрудник может занимать несколько комнат)
	![[Pasted image 20251013204623.png]]
В N-арных ассоциациях используются взаимосвязи между тремя и более классами, а это не поддерживается

2. Агрегация (часть-целое, но часть может существовать отдельно и является самостоятельной)
	* У нас есть департамент, куда относится много сотрудников. И есть соответствующие методы для взаимодействия между этими классами. Оба объекта создаются отдельно и существуют независимо
	* ![[Pasted image 20251013204909.png]]

3. Композиция
	* Отличие только в том, что зависимая часть всегда создается внутри целого. И поэтому часть не может без него существовать
	* ![[Pasted image 20251013205214.png]]
	* Части всегда должны ликвидироваться в деструкторе

4. Зависимость
	* Не нуждается в иллюстрации, т.к. это банальное наследование

5. Реализация
	* Не нуждается в иллюстрации, т.к. это банальное наследование от виртуального класса (интерфейса)

#### Про интерфейсные классы



