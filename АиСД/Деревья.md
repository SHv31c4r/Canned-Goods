Дерево - граф, у которого есть узел (корень), в который не входит ни одной дуги, а в каждую остальную вершину входит одна дуга.

Дерево - это граф, внутри которого нет цикла.
## Элементы дерева:
1. Корень - вершина, у которой нет предка.
2. Лист - вершина, у которой нет потомка.
3. Потомок - вершина, в которую входит ребро.
4. Предок (родитель) - вершина, из которой выходит ребро.
Уровень дерева - набор вершин, находящихся на одном уровне от корня.
Поддерево - часть дерева, состоящая из вершины дерева и всех ее потомков.
Дерево - это рекурсивная конструкция.
Высота дерева - это максимальное количество вершин от корня дерева до его листа.
Степень вершины дерева:
1. Двоичные (бинарные) - потомков у вершины не больше двух.
2. Сильноветвящиеся - потомков у вершины от трех и более.
![[Pasted image 20241106153010.png]]
## Реализация дерева в программе:
1. Динамическая, с помощью указателей потомков. Узел дерева содержит данные и поля-указатели на потомков.
![[Pasted image 20241106153312.png]] ![[Pasted image 20241106153325.png]]
2. Статическая, в массиве (только для бинарного дерева). Индекс каждой вершины рассчитывается по формуле.
![[Pasted image 20241106153345.png]]
3. Как граф, с помощью матрицы смежности/инцидентности.
## Обход дерева
Обход дерева - перебор всех элементов. Обход дерева может иметь как рекурсивную, так и нерекурсивную реализации.

Обход в любом виде осуществляет доступ ко всем элементам дерева. Отличие лишь в порядке доступа к вершин

Виды обходов (не блокировок ркн, а дерева):

1. Прямой
![[Pasted image 20241106153842.png]]

Прямой обход является рекурсивным, осуществляется от корня до крайнего левого листа, затем поднимается на одну ступень выше, чтобы пройти к правому элементу. И так вплоть до самого правого листа.

2. Обратный
![[Pasted image 20241106154316.png]]

Обход начинается от крайнего левого листа. Затем проверяем, есть ли еще один потомок, и смотрим его. Потом поднимаемся на уровень выше. С этого уровня идем назад на нижнее, но у соседнего справа поддерева. Продолжать до прохождения к корню дерева.

3. Симметричный
![[Pasted image 20241106154107.png]]

Обход начинается от крайнего левого листа. Затем поднимаемся на уровень выше, смотрим родителя. Если есть еще один потомок, то идем к потомку правее. И так до корня. Потом от корня спускаемся вниз.

## Чут-чут про рекурсию
В рекурсии должно быть условие (if), которое проверяет ситуацию. Если ситуация простая, то возвращается ответ (он является завершением рекурсии [многократного вызова]). Иначе будет рекурсивный вызов с измененным параметром функции (например, уменьшаться).

##### Все три способа обхода рекурсивно можно определить следующим образом:
1. если дерево Tree является пустым деревом, то в список обхода заносится пустая запись;
2. если дерево Tree состоит из одной вершины, то в список обхода записывается эта вершина;
3. если Tree – дерево с корнем n и поддеревьями Tree1, Tree2, …, Treek, то:

– при прохождении в ***прямом порядке*** сначала посещается корень n, затем в прямом порядке вершины поддерева Tree1, далее в прямом порядке вершины поддерева Tree2 и т. д. Последними в прямом порядке посещаются вершины поддерева Treek;

– при прохождении в ***обратном порядке*** сначала посещаются в обратном порядке вершины поддерева Tree1, далее последовательно в обратном порядке посещаются вершины поддеревьев Tree2, …, Treek. Последним посещается корень n;

– при прохождении в ***симметричном порядке*** сначала посещаются в симметричном порядке вершины поддерева Tree1, далее корень n, затем последовательно в симметричном порядке вершины поддеревьев Tree2, …, Treek.

## Практическое применение деревьев

Деревья применяются для хранения данных. Но их тогда надо организовать.
### Упорядоченные деревья
Однако можно организовать хранение элементов в дереве так, чтобы при поиске элемента достаточно было просмотреть лишь часть дерева. Для этого надо ввести следующее требование упорядоченности дерева:

Двоичное дерево упорядочено, если для любой вершины _x_ справедливо такое свойство: все элементы, хранимые в левом поддереве, меньше элемента, хранимого в _x_, а все элементы, хранимые в правом поддереве, больше элемента, хранимого в _x_.

Форма дерева зависит от порядка внесения данных. Могут быть вырождены случаи - линейные списки.

Важное свойство упорядоченного дерева: все элементы его различны. Если в дереве встречаются одинаковые элементы, то такое дерево является частично упорядоченным.

## Сбалансированные по высоте деревья поиска

#### 1. АВЛ дерево
АВЛ дерево гарантирует быстрый поиск, так как, помимо требования по упорядоченности двоичного дерева (т.е. у него нет случая с вырожденностью в список), у него есть дополнительное требование: высота левого и правого поддеревьев отличаются НЕ БОЛЕЕ, чем на один пункт.

Чтобы выполнить эти требования, нужно провести балансировку. Балансировка изменения АВЛ дерева осуществляется при невыполнении дополнительного требования.
У балансировки есть два вида действия:
1. Малое вращение - расположение меняет только один узел ()
2. Большое вращение - два узла разворачиваются в разные стороны()
